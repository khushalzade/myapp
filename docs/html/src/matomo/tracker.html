<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.matomo.tracker API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.matomo.tracker</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import datetime
import hashlib
import json
import random
import re
import time
from urllib.parse import quote, parse_qs, urlencode
import uuid


def urlencode_plus(s):
    if type(s) == str:
        return quote(s)
    elif type(s) == dict:
        return urlencode(s)
    else:
        raise TypeError(&#34;urlencode_plus works only on strings and dicts.&#34;, s)

#
# This module is hand-corrected version of an automated translation of PHP MatomoTracker
#

is_int = lambda x: isinstance(x, int)
is_list = lambda x: isinstance(x, list)
is_dict = lambda x: isinstance(x, dict)
is_numeric = lambda x: isinstance(x, float)  # Used only once with float parameter
strpos = lambda s, sub: s.find(sub) if s.find(sub) != -1 else False


def strspn(str1, str2, start=0, length=None):
    if not length:
        length = len(str1)
    return len(re.search(&#34;^[&#34; + str2 + &#34;]*&#34;, str1[start : start + length]).group(0))


&#34;&#34;&#34;
 * Matomo - free/libre analytics platform

 * For more information, see README.md

 * @license released under BSD License http://www.opensource.org/licenses/bsd-license.php
 * @link https://matomo.org/docs/tracking-api/

 * @category Matomo
 * @package MatomoTracker
&#34;&#34;&#34;

class MatomoTracker:
    &#34;&#34;&#34;
    MatomoTracker implements the Matomo Tracking Web API.

    For more information, see: https://github.com/matomo-org/matomo-php-tracker/

    * @package MatomoTracker
    * @api
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    Matomo base URL, for example http://example.org/matomo/
    Must be set before using the class by calling
    MatomoTracker.URL = &#39;http://yourwebsite.org/matomo/&#39;

    * @var str
    &#34;&#34;&#34;
    URL = &#34;&#34;

    &#34;&#34;&#34;
    API Version

    * @ignore
    * @var int
    &#34;&#34;&#34;
    VERSION = 1

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    DEBUG_APPEND_URL = &#34;&#34;

    &#34;&#34;&#34;
    Visitor ID length

    * @ignore
    &#34;&#34;&#34;
    LENGTH_VISITOR_ID = 16

    &#34;&#34;&#34;
    Charset
    * @see set_page_charset
    * @ignore
    &#34;&#34;&#34;
    DEFAULT_CHARSET_PARAMETER_VALUES = &#34;utf-8&#34;

    &#34;&#34;&#34;
    See matomo.js
    &#34;&#34;&#34;
    FIRST_PARTY_COOKIES_PREFIX = &#34;_pk_&#34;

    &#34;&#34;&#34;
    Defines how many categories can be used max when calling add_ecommerce_item().
    * @var int
    &#34;&#34;&#34;
    MAX_NUM_ECOMMERCE_ITEM_CATEGORIES = 5

    DEFAULT_COOKIE_PATH = &#34;/&#34;

    def __init__(self, request, id_site, api_url=&#34;&#34;):
        &#34;&#34;&#34;
        Builds a MatomoTracker object, used to track visits, pages and Goal conversions
        for a specific website, by using the Matomo Tracking API.

        * @param int id_site Id site to be tracked
        * @param str api_url &#34;http://example.org/matomo/&#34; or &#34;http://matomo.example.org/&#34;
                                If set, will overwrite MatomoTracker.URL
        &#34;&#34;&#34;
        self.request = request
        self.request_method = &#34;GET&#34;
        self.ecommerceItems = []
        self.attributionInfo = []
        self.eventCustomVar = {}
        self.forcedDatetime = &#34;&#34;
        self.forcedNewVisit = False
        self.networkTime = 0
        self.serverTime = 0
        self.transferTime = 0
        self.domProcessingTime = 0
        self.domCompletionTime = 0
        self.onLoadTime = 0
        self.pageCustomVar = {}
        self.ecommerceView = {}
        self.customParameters = {}
        self.customDimensions = {}
        self.customData = &#34;&#34;
        self.hasCookies = False
        self.token_auth = &#34;&#34;
        self.user_agent = &#34;&#34;
        self.country = &#34;&#34;
        self.region = &#34;&#34;
        self.city = &#34;&#34;
        self.lat = 0.0
        self.long = 0.0
        self.width = 0
        self.height = 0
        self.plugins = &#34;&#34;
        self.local_hour = &#34;&#34;
        self.local_minute = &#34;&#34;
        self.local_second = &#34;&#34;
        self.idPageview = &#34;&#34;

        self.id_site = str(id_site)
        self.urlReferrer = self.request.get(&#34;HTTP_REFERER&#34;, &#34;&#34;)
        self.pageCharset = self.DEFAULT_CHARSET_PARAMETER_VALUES
        self.pageUrl = self.get_current_url()
        self.ip = self.request.get(&#34;REMOTE_ADDR&#34;, &#34;&#34;)
        self.accept_language = self.request.get(&#34;HTTP_ACCEPT_LANGUAGE&#34;, &#34;&#34;)
        self.user_agent = self.request.get(&#34;HTTP_USER_AGENT&#34;, &#34;&#34;)
        if api_url:
            self.URL = api_url

        # Life of the visitor cookie (in sec)
        self.configVisitorCookieTimeout = 33955200
        # 13 months (365 + 28 days)
        # Life of the session cookie (in sec)
        self.configSessionCookieTimeout = 1800
        # 30 minutes
        # Life of the session cookie (in sec)
        self.configReferralCookieTimeout = 15768000
        # 6 months

        # Visitor Ids in order
        self.user_id = &#34;&#34;
        self.forcedVisitorId = &#34;&#34;
        self.cookieVisitorId = &#34;&#34;
        self.randomVisitorId = &#34;&#34;

        self.set_new_visitor_id()

        self.configCookiesDisabled = False
        self.configCookiePath = self.DEFAULT_COOKIE_PATH
        self.configCookieDomain = &#34;&#34;
        self.configCookieSameSite = &#34;&#34;
        self.configCookieSecure = False
        self.configCookieHTTPOnly = False

        self.currentTs = time.time()
        self.createTs = self.currentTs

        # Allow debug while blocking the request
        self.requestTimeout = 600
        self.doBulkRequests = False
        self.storedTrackingActions = []

        self.sendImageResponse = True

        self.visitorCustomVar = self.get_custom_variables_from_cookie()

        self.outgoingTrackerCookies = {}
        self.incomingTrackerCookies = {}

        self.headersSent = False

        self.proxy = &#34;&#34;
        self.proxy_port = &#34;&#34;
        self.proxy_type = &#34;https&#34;

    def set_page_charset(self, charset=&#34;&#34;):
        &#34;&#34;&#34;
        By default, Matomo expects utf-8 encoded values, for example
        for the page URL parameter values, Page Title, etc.
        It is recommended to only send UTF-8 data to Matomo.
        If required though, you can also specify another charset using this function.

        * @param str charset
        * @return self
        &#34;&#34;&#34;
        self.pageCharset = charset
        return self

    def set_url(self, url):
        &#34;&#34;&#34;
        Sets the current URL being tracked

        * @param str url Raw URL (not URL encoded)
        * @return self
        &#34;&#34;&#34;
        self.pageUrl = url
        return self

    def set_url_referrer(self, url):
        &#34;&#34;&#34;
        Sets the URL referrer used to track Referrers details for new visits.

        * @param str url Raw URL (not URL encoded)
        * @return self
        &#34;&#34;&#34;
        self.urlReferrer = url
        return self

    def set_generation_time(self, time_ms):
        &#34;&#34;&#34;
        This method is deprecated and does nothing. It used to set the time that it took to generate the document on the server side.

        * @param int time_ms Generation time in ms
        * @return self

        * @deprecated this metric is deprecated please use performance timings instead
        * @see setPerformanceTimings
        &#34;&#34;&#34;
        return self

    def set_performance_timings(self, network=0, server=0, transfer=0, domProcessing=0, domCompletion=0, onLoad=0):
        &#34;&#34;&#34;
        Sets timings for various browser performance metrics.
        * @see https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming

        * @param int network Network time in ms (connectEnd – fetchStart)
        * @param int server Server time in ms (responseStart – requestStart)
        * @param int transfer Transfer time in ms (responseEnd – responseStart)
        * @param int domProcessing DOM Processing to Interactive time in ms (domInteractive – domLoading)
        * @param int domCompletion DOM Interactive to Complete time in ms (domComplete – domInteractive)
        * @param int onload Onload time in ms (loadEventEnd – loadEventStart)
        * @return self
        &#34;&#34;&#34;
        self.networkTime = network
        self.serverTime = server
        self.transferTime = transfer
        self.domProcessingTime = domProcessing
        self.domCompletionTime = domCompletion
        self.onLoadTime = onLoad
        return self

    def clear_performance_timings(self):
        &#34;&#34;&#34;
        Clear / reset all previously set performance metrics.
        &#34;&#34;&#34;
        self.networkTime = 0
        self.serverTime = 0
        self.transferTime = 0
        self.domProcessingTime = 0
        self.domCompletionTime = 0
        self.onLoadTime = 0

    def set_url_referer(self, url):
        &#34;&#34;&#34;
        * @deprecated
        * @ignore
        &#34;&#34;&#34;
        self.set_url_referrer(url)
        return self

    def set_attribution_info(self, json_encoded):
        &#34;&#34;&#34;
        Sets the attribution information to the visit, so that subsequent Goal conversions are
        properly attributed to the right Referrer URL, timestamp, Campaign Name &amp; Keyword.

        This must be a JSON encoded string that would typically be fetched from the JS API:
        matomoTracker.get_attribution_info() and that you have JSON encoded via JSON2.stringify()

        If you call enable_cookies() then these referral attribution values will be set
        to the &#39;ref&#39; first party cookie storing referral information.

        * @param str json_encoded JSON encoded list containing Attribution info
        * @return self
        * @throws Exception
        * @see def getAttributionInfo(self): in https://github.com/matomo-org/matomo/blob/master/js/matomo.js
        &#34;&#34;&#34;
        decoded = json.loads(json_encoded)
        if not is_list(decoded):
            raise Exception(
                f&#34;set_attribution_info() is expecting a JSON encoded string, &#39;{json_encoded}&#39; given&#34;
            )
        self.attributionInfo = decoded
        return self

    def set_custom_variable(self, id, name, value, scope=&#34;visit&#34;):
        &#34;&#34;&#34;
        Sets Visit Custom Variable.
        See https://matomo.org/docs/custom-variables/

        * @param int id Custom variable slot ID from 1-5
        * @param str name Custom variable name
        * @param str value Custom variable value
        * @param str scope Custom variable scope. Possible values: visit, page, event
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if not is_int(id):
            raise Exception(&#34;Parameter id to set_custom_variable should be an integer&#34;)
        if scope == &#34;page&#34;:
            self.pageCustomVar[id] = [name, value]
        elif scope == &#34;event&#34;:
            self.eventCustomVar[id] = [name, value]
        elif scope == &#34;visit&#34;:
            self.visitorCustomVar[id] = [name, value]
        else:
            raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
        return self

    def get_custom_variable(self, id, scope=&#34;visit&#34;):
        &#34;&#34;&#34;
        Returns the currently assigned Custom Variable.

        If scope is &#39;visit&#39;, it will attempt to read the value set in the first party cookie created by Matomo Tracker
         (self.request.cookie array).

        * @param int id Custom Variable integer index to fetch from cookie. Should be a value from 1 to 5
        * @param str scope Custom variable scope. Possible values: visit, page, event

        * @throws Exception
        * @return list A list with this format: [ CustomVariableName, CustomVariableValue ] or False
        * @see matomo.js getCustomVariable()
        &#34;&#34;&#34;
        if scope == &#34;page&#34;:
            return self.pageCustomVar.get(id, False)
        elif scope == &#34;event&#34;:
            return self.eventCustomVar.get(id, False)
        else:
            if scope != &#34;visit&#34;:
                raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
        if self.visitorCustomVar.get(id):
            return self.visitorCustomVar[id]

        cookie_decoded = self.get_custom_variables_from_cookie()
        if not is_int(id):
            raise Exception(&#34;Parameter to get_custom_variable should be an integer&#34;)
        if (
            not is_dict(cookie_decoded)
            or id not in cookie_decoded
            or not is_list(cookie_decoded[id])
            or len(cookie_decoded[id]) != 2
        ):
            return False

        return cookie_decoded[id]

    def clear_custom_variables(self):
        &#34;&#34;&#34;
        Clears any Custom Variable that may be have been set.

        This can be useful when you have enabled bulk requests,
        and you wish to clear Custom Variables of &#39;visit&#39; scope.
        &#34;&#34;&#34;
        self.visitorCustomVar = {}
        self.pageCustomVar = {}
        self.eventCustomVar = {}

    def set_custom_dimension(self, id, value):
        &#34;&#34;&#34;
        Sets a specific custom dimension

        * @param int id id of custom dimension
        * @param str value value for custom dimension
        * @return self
        &#34;&#34;&#34;
        self.customDimensions[f&#34;dimension{id}&#34;] = value
        return self

    def clear_custom_dimensions(self):
        &#34;&#34;&#34;
        Clears all previously set custom dimensions
        &#34;&#34;&#34;
        self.customDimensions = {}

    def get_custom_dimension(self, id):
        &#34;&#34;&#34;
        Returns the value of the custom dimension with the given id

        * @param int id id of custom dimension
        * @return str | None
        &#34;&#34;&#34;
        return self.customDimensions.get(f&#34;dimension{id}&#34;, None)

    def set_custom_tracking_parameter(self, tracking_api_parameter, value):
        &#34;&#34;&#34;
        Sets a custom tracking parameter. This is useful if you need to send any tracking parameters for a 3rd party
        plugin that is not shipped with Matomo itself. Please note that custom parameters are cleared after each
        tracking request.

        * @param str tracking_api_parameter The name of the tracking API parameter, eg &#39;bw_bytes&#39;
        * @param str value Tracking parameter value that shall be sent for this tracking parameter.
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        regex = re.compile(&#39;/^dimension([0-9]+)$/&#39;)
        matches = re.findall(regex, tracking_api_parameter)
        if len(matches):
            # Unlike PHP preg_match it returns captured subpattern as first element
            self.set_custom_dimension(matches[0], value)
            return self

        self.customParameters[tracking_api_parameter] = value
        return self

    def clear_custom_tracking_parameters(self):
        &#34;&#34;&#34;
        Clear / reset all previously set custom tracking parameters.
        &#34;&#34;&#34;
        self.customParameters = {}

    def set_new_visitor_id(self):
        &#34;&#34;&#34;
        Sets the current visitor ID to a random new one.
        * @return self
        &#34;&#34;&#34;
        self.randomVisitorId = uuid.uuid4().hex[: self.LENGTH_VISITOR_ID]
        self.forcedVisitorId = False
        self.cookieVisitorId = False
        return self

    def set_id_site(self, id_site):
        &#34;&#34;&#34;
        Sets the current site ID.

        * @param int id_site
        * @return self
        &#34;&#34;&#34;
        self.id_site = id_site
        return self

    def set_browser_language(self, accept_language):
        &#34;&#34;&#34;
        Sets the Browser language. Used to guess visitor countries when GeoIP is not enabled

        * @param str accept_language For example &#34;fr-fr&#34;
        * @return self
        &#34;&#34;&#34;
        self.accept_language = accept_language
        return self

    def set_user_agent(self, user_agent):
        &#34;&#34;&#34;
        Sets the user agent, used to detect OS and browser.
        If this function is not called, the User Agent will default to the current user agent.

        * @param str user_agent
        * @return self
        &#34;&#34;&#34;
        self.user_agent = user_agent
        return self

    def set_country(self, country):
        &#34;&#34;&#34;
        Sets the country of the visitor. If not used, Matomo will try to find the country
        using either the visitor&#39;s IP address or language.

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str country
        * @return self
        &#34;&#34;&#34;
        self.country = country
        return self

    def set_region(self, region):
        &#34;&#34;&#34;
        Sets the region of the visitor. If not used, Matomo may try to find the region
        using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str region
        * @return self
        &#34;&#34;&#34;
        self.region = region
        return self

    def set_city(self, city):
        &#34;&#34;&#34;
        Sets the city of the visitor. If not used, Matomo may try to find the city
        using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str city
        * @return self
        &#34;&#34;&#34;
        self.city = city
        return self

    def set_latitude(self, lat):
        &#34;&#34;&#34;
        Sets the latitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
        latitude using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param float lat
        * @return self
        &#34;&#34;&#34;
        self.lat = lat
        return self

    def set_longitude(self, long):
        &#34;&#34;&#34;
        Sets the longitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
        longitude using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param float long
        * @return self
        &#34;&#34;&#34;
        self.long = long
        return self

    def enable_bulk_tracking(self):
        &#34;&#34;&#34;
        Enables the bulk request feature. When used, each tracking action is stored until the
        do_bulk_track method is called. This method will send all tracking data at once.

        &#34;&#34;&#34;
        self.doBulkRequests = True

    def enable_cookies(
        self, domain=&#34;&#34;, path=&#34;/&#34;, secure=False, http_only=False, same_site=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Enable cookie creation - this will cause a first party VisitorId cookie to be set when the VisitorId is set or reset

        * @param str domain (optional) Set first-party cookie domain.
                    Accepted values: example.com, *.example.com (same as .example.com) or subdomain.example.com
        * @param str path (optional) Set first-party cookie path
        * @param bool secure (optional) Set secure flag for cookies
        * @param bool http_only (optional) Set HTTPOnly flag for cookies
        * @param str same_site (optional) Set SameSite flag for cookies
        &#34;&#34;&#34;
        self.configCookiesDisabled = False
        self.configCookieDomain = self.domain_fixup(domain)
        self.configCookiePath = path
        self.configCookieSecure = secure
        self.configCookieHTTPOnly = http_only
        self.configCookieSameSite = same_site

    def disable_send_image_response(self):
        &#34;&#34;&#34;
        If image response is disabled Matomo will respond with a HTTP 204 header instead of responding with a gif.
        &#34;&#34;&#34;
        self.sendImageResponse = False

    def domain_fixup(self, domain):
        &#34;&#34;&#34;
        Fix-up domain

        Remove trailing &#39;.&#39; and leading &#39;*.&#39;
        &#34;&#34;&#34;
        return domain.rstrip(&#34;.&#34;).lstrip(&#34;*.&#34;)

    def get_cookie_name(self, cookie_name):
        &#34;&#34;&#34;
        Get cookie name with prefix and domain hash
        * @param str cookie_name
        * @return str
        &#34;&#34;&#34;
        hash_string = hashlib.sha1(
            (
                self.get_current_host()
                if self.configCookieDomain == &#34;&#34;
                else self.configCookieDomain
            ).encode(&#34;utf-8&#34;)
            + self.configCookiePath.encode(&#34;utf-8&#34;)
        ).hexdigest()[:4]

        return &#34;{}{}.{}.{}&#34;.format(
            self.FIRST_PARTY_COOKIES_PREFIX,
            cookie_name,
            self.id_site,
            hash_string
        )

    def do_track_page_view(self, document_title):
        &#34;&#34;&#34;
        Tracks a page view

        * @param str document_title Page title as it will appear in the Actions &gt; Page titles report
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        self.generate_new_pageview_id()
        url = self.get_url_track_page_view(document_title)
        return self.send_request(url)

    def generate_new_pageview_id(self):
        self.idPageview = uuid.uuid4().hex[:6]

    def do_track_event(self, category, action, name=&#34;&#34;, value=0):
        &#34;&#34;&#34;
        Tracks an event

        * @param str category The Event Category (Videos, Music, Games...)
        * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
        * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
        * @param float value (optional) The Event&#39;s value
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_event(category, action, name, value)
        return self.send_request(url)

    def do_track_content_impression(
        self, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Tracks a content impression

        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str content_target (optional) The target of the content. For instance the URL of a landing page.
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_content_impression(
            content_name, content_piece, content_target
        )
        return self.send_request(url)

    def do_track_content_interaction(
        self, interaction, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Tracks a content interaction. Make sure you have tracked a content impression using the same content name and
        content piece, otherwise it will not count. To do so you should call the method do_track_content_impression()

        * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_content_interaction(
            interaction, content_name, content_piece, content_target
        )

        return self.send_request(url)

    def do_track_site_search(self, keyword, category=&#34;&#34;, count_results=0):
        &#34;&#34;&#34;
        Tracks an internal Site Search query, and optionally tracks the Search
        Category, and Search results Count.
        These are used to populate reports in Actions &gt; Site Search.

        * @param str keyword Searched query on the site
        * @param str category (optional) Search engine category if applicable
        * @param int count_results (optional) results displayed on the search
        result page. Used to track &#34;zero result&#34; keywords.

        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_site_search(keyword, category, count_results)
        return self.send_request(url)

    def do_track_goal(self, id_goal, revenue=0.0):
        &#34;&#34;&#34;
        Records a Goal conversion

        * @param int id_goal Id Goal to record a conversion
        * @param float revenue Revenue for this conversion
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_goal(id_goal, revenue)
        return self.send_request(url)

    def do_track_action(self, action_url, action_type):
        &#34;&#34;&#34;
        Tracks a download or outlink

        * @param str action_url URL of the download or outlink
        * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        # Referrer could be updated to be the current URL temporarily (to mimic JS behavior)
        url = self.get_url_track_action(action_url, action_type)
        return self.send_request(url)

    def add_ecommerce_item(self, sku, name=&#34;&#34;, category=&#34;&#34;, price=0.0, quantity=1):
        &#34;&#34;&#34;
        Adds an item in the Ecommerce order.

        This should be called before do_track_ecommerce_order(), or before do_track_ecommerce_cart_update().
        This function can be called for all individual products in the cart (self, or order):.
        SKU parameter is mandatory. Other parameters are optional (set to False if value not known).
        Ecommerce items added via this function are automatically cleared when
        do_track_ecommerce_order() or get_url_track_ecommerce_order() is called.

        * @param str sku (required) SKU, Product identifier
        * @param str name (optional) Product name
        * @param str|list category (optional) Product category, or list of product categories (up to 5 categories can be specified for a given product)
        * @param float|int price (optional) Individual product price (supports integer and decimal prices)
        * @param int quantity (optional) Product quantity. If specified, will default to 1 not in the Reports
        * @throws Exception
        * @return self
        &#34;&#34;&#34;
        if not sku:
            raise Exception(&#34;You must specify a SKU for the Ecommerce item&#34;)

        price = self.force_dot_as_separator_for_decimal_point(price)
        self.ecommerceItems = [sku, name, category, price, quantity]
        return self

    def do_track_ecommerce_cart_update(self, grand_total):
        &#34;&#34;&#34;
        Tracks a Cart Update (add item, remove item, update item).

        On every Cart update, you must call add_ecommerce_item() for each item
        (product) in the cart, including the items that haven&#39;t been updated
        since the last cart update.
        Items which were in the previous cart and are sent not in later Cart
        updates will be deleted from the cart (in the database).

        * @param float grand_total Cart grand_total (typically the sum of all items&#39; prices)
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce_cart_update(grand_total)
        return self.send_request(url)

    def do_bulk_track(self):
        &#34;&#34;&#34;
        Sends all stored tracking actions at once. Only has an effect if bulk tracking is enabled.

        To enable bulk tracking, call enable_bulk_tracking().

        * @throws Exception
        * @return str Response
        &#34;&#34;&#34;
        if not self.storedTrackingActions:
            raise Exception(
                (
                    &#34;Error: you must call the function do_track_page_view or do_track_goal&#34;
                    &#34; from this class, before calling this method do_bulk_track():&#34;
                )
            )

        data = {&#34;requests&#34;: self.storedTrackingActions}

        # token_auth is not required by default, except if bulk_requests_require_authentication=1
        if self.token_auth:
            data[&#34;token_auth&#34;] = self.token_auth

        post_data = json.dumps(data)
        response = self.send_request(self.get_base_url(), &#34;POST&#34;, post_data, force=True)

        self.storedTrackingActions = []

        return response

    def do_track_ecommerce_order(
        self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Tracks an Ecommerce order.

        If the Ecommerce order contains items (products), you must call first the add_ecommerce_item() for each item in the order.
        All revenues (grand_total, sub_total, tax, shipping, discount) will be individually summed and reported in Matomo reports.
        Only the parameters order_id and grand_total are required.

        * @param str|int order_id (required) Unique Order ID.
                       This will be used to count this order only once in the event the order page is reloaded several times.
                       order_id must be unique for each transaction, even on different days, or the transaction will not be recorded by Matomo.
        * @param float grand_total (required) Grand Total revenue of the transaction (including tax, shipping, etc.)
        * @param float sub_total (optional) Sub total amount, typically the sum of items prices for all items in this order (before Tax and Shipping costs are applied)
        * @param float tax (optional) Tax amount for this order
        * @param float shipping (optional) Shipping amount for this order
        * @param float discount (optional) Discounted amount in this order
        * @return mixed Response or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce_order(
            order_id, grand_total, sub_total, tax, shipping, discount
        )
        return self.send_request(url)

    def do_ping(self):
        &#34;&#34;&#34;
        Sends a ping request.

        Ping requests do track new actions. If they are sent within the standard visit length (see global.ini.php), * they will extend the existing visit and the current last action for the visit. If after the standard visit length, * ping requests will create a new visit using the last action not in the last known visit.

        * @return mixed Response or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += &#34;&amp;ping=1&#34;

        return self.send_request(url)

    def set_ecommerce_view(self, sku=&#34;&#34;, name=&#34;&#34;, category=&#34;&#34;, price=0.0):
        &#34;&#34;&#34;
        Sets the current page view as an item (product) page view, or an Ecommerce Category page view.

        This must be called before do_track_page_view() on this product/category page.

        On a category page, you may set the parameter category only and set the other parameters to False.

        Tracking Product/Category page views will allow Matomo to report on Product &amp; Categories
        conversion rates (Conversion rate = Ecommerce orders containing this product or category / Visits to the product or category)

        * @param str sku Product SKU being viewed
        * @param str name Product Name being viewed
        * @param str|array category Category being viewed. On a Product page, this is the product&#39;s category.
                                       You can also specify an array of up to 5 categories for a given page view.
        * @param float price Specify the price at which the item was displayed
        * @return self
        &#34;&#34;&#34;
        self.ecommerceView = {}
        if category:
            if is_list(category):
                category = json.dumps(category)

        self.ecommerceView[&#34;_pkc&#34;] = category

        if price:
            price = str(price)
            price = self.force_dot_as_separator_for_decimal_point(price)
            self.ecommerceView[&#34;_pkp&#34;] = price

        # On a category page, do not record &#34;Product name not defined&#34;
        if not sku and not name:
            return self
        if sku:
            self.ecommerceView[&#34;_pks&#34;] = sku
        if not name:
            name = &#34;&#34;
        self.ecommerceView[&#34;_pkn&#34;] = name
        return self

    def force_dot_as_separator_for_decimal_point(self, value):
        &#34;&#34;&#34;
        Force the separator for decimal point to be a dot. See https://github.com/matomo-org/matomo/issues/6435
        If for instance a German locale is used it would be a comma otherwise.

        * @param  float|string value
        * @return str
        &#34;&#34;&#34;
        if value is None or value is False:
            return &#34;&#34;
        return str(value).replace(&#34;,&#34;, &#34;.&#34;)

    def get_url_track_ecommerce_cart_update(self, grand_total):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce Cart updates
        Calling this function will reinitialize the property ecommerceItems to empty list
        so items will have to be added again via add_ecommerce_item()
        * @ignore
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce(grand_total)
        return url

    def get_url_track_ecommerce_order(
        self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce Orders
        Calling this function will reinitialize the property ecommerceItems to empty list
        so items will have to be added again via add_ecommerce_item()
        * @ignore
        &#34;&#34;&#34;
        if not order_id:
            raise Exception(&#34;You must specify an order_id for the Ecommerce order&#34;)
        url = self.get_url_track_ecommerce(
            grand_total, sub_total, tax, shipping, discount
        )
        url += &#34;&amp;ec_id=&#34; + urlencode_plus(order_id)

        return url

    def get_url_track_ecommerce(
        self, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce orders

        Calling this function will reinitialize the property ecommerceItems to empty array
        so items will have to be added again via add_ecommerce_item()

        * @ignore
        &#34;&#34;&#34;
        if not is_numeric(grand_total) and not is_int(grand_total):
            raise Exception(
                &#34;You must specify a grand_total for the Ecommerce order (or Cart update)&#34;
            )

        url = self.get_request(self.id_site)
        url += &#34;&amp;idgoal=0&#34;
        if grand_total:
            grand_total = self.force_dot_as_separator_for_decimal_point(grand_total)
            url += f&#34;&amp;revenue={grand_total}&#34;
        if sub_total:
            sub_total = self.force_dot_as_separator_for_decimal_point(sub_total)
            url += f&#34;&amp;ec_st={sub_total}&#34;
        if tax:
            tax = self.force_dot_as_separator_for_decimal_point(tax)
            url += f&#34;&amp;ec_tx={tax}&#34;
        if shipping:
            shipping = self.force_dot_as_separator_for_decimal_point(shipping)
            url += f&#34;&amp;ec_sh={shipping}&#34;
        if discount:
            discount = self.force_dot_as_separator_for_decimal_point(discount)
            url += f&#34;&amp;ec_dt={discount}&#34;
        if self.ecommerceItems:
            url += &#34;&amp;ec_items=&#34; + urlencode_plus(json.dumps(self.ecommerceItems))
        self.ecommerceItems = []

        return url

    def get_url_track_page_view(self, document_title=&#34;&#34;):
        &#34;&#34;&#34;
        Builds URL to track a page view.

        * @see do_track_page_view()
        * @param str document_title Page view name as it will appear in Matomo reports
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        if document_title:
            url += &#34;&amp;action_name=&#34; + urlencode_plus(document_title)
        return url

    def get_url_track_event(self, category, action, name=&#34;&#34;, value=0):
        &#34;&#34;&#34;
        Builds URL to track a custom event.

        * @see do_track_event()
        * @param str category The Event Category (Videos, Music, Games...)
        * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
        * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
        * @param float value (optional) The Event&#39;s value
        * @return str URL to matomo.php with all parameters set to track the pageview
        * @throws
        &#34;&#34;&#34;
        if not category:
            raise Exception(
                &#34;You must specify an Event Category name (Music, Videos, Games...).&#34;
            )
        if not action:
            raise Exception(&#34;You must specify an Event action (click, view, add...).&#34;)

        url = self.get_request(self.id_site)
        url += f&#34;&amp;e_c={urlencode_plus(category)}&amp;e_a={urlencode_plus(action)}&#34;

        if name:
            url += f&#34;&amp;e_n={urlencode_plus(name)}&#34;
        if value:
            value = self.force_dot_as_separator_for_decimal_point(value)
            url += f&#34;&amp;e_v={value}&#34;

        return url

    def get_url_track_content_impression(
        self, content_name, content_piece, content_target
    ):
        &#34;&#34;&#34;
        Builds URL to track a content impression.

        * @see do_track_content_impression()
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str|False content_target (optional) The target of the content. For instance the URL of a landing page.
        * @throws Exception In case content_name is empty
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)

        if not content_name:
            raise Exception(&#34;You must specify a content name&#34;)

        url += f&#34;&amp;c_n={urlencode_plus(content_name)}&#34;

        if content_piece:
            url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
        if content_target:
            url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

        return url

    def get_url_track_content_interaction(
        self, interaction, content_name, content_piece, content_target
    ):
        &#34;&#34;&#34;
        Builds URL to track a content impression.

        * @see do_track_content_interaction()
        * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str|False content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
        * @throws Exception In case interaction or content_name is empty
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)

        if not interaction:
            raise Exception(&#34;You must specify a name for the interaction&#34;)

        if not content_name:
            raise Exception(&#34;You must specify a content name&#34;)

        url += f&#34;&amp;c_i={urlencode_plus(interaction)}&amp;c_n={urlencode_plus(content_name)}&#34;

        if content_piece:
            url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
        if content_target:
            url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

        return url

    def get_url_track_site_search(self, keyword, category, count_results):
        &#34;&#34;&#34;
        Builds URL to track a site search.

        * @see do_track_site_search()
        * @param str keyword
        * @param str category
        * @param int count_results
        * @return str
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;search=&#34; + urlencode_plus(keyword)
        if category:
            url += f&#34;&amp;search_cat={urlencode_plus(category)}&#34;
        if count_results or count_results == 0:
            url += f&#34;&amp;search_count={count_results}&#34;

        return url

    def get_url_track_goal(self, id_goal, revenue=0.0):
        &#34;&#34;&#34;
        Builds URL to track a goal with id_goal and revenue.

        * @see do_track_goal()
        * @param int id_goal Id Goal to record a conversion
        * @param float revenue Revenue for this conversion
        * @return str URL to matomo.php with all parameters set to track the goal conversion
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;idgoal={id_goal}&#34;
        if revenue:
            revenue = self.force_dot_as_separator_for_decimal_point(revenue)
            url += f&#34;&amp;revenue={revenue}&#34;

        return url

    def get_url_track_action(self, action_url, action_type):
        &#34;&#34;&#34;
        Builds URL to track a new action.

        * @see do_track_action()
        * @param str action_url URL of the download or outlink
        * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
        * @return str URL to matomo.php with all parameters set to track an action
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;{action_type}={urlencode_plus(action_url)}&#34;
        return url

    def set_force_visit_date_time(self, date_time):
        &#34;&#34;&#34;
        Overrides server date and time for the tracking requests.
        By default Matomo will track requests for the &#34;current datetime&#34; but this function allows you
        to track visits in the past. All times are in UTC.

        Allowed only for Admin/Super User, must be used along with set_token_auth()
        * @see set_token_auth()
        * @param str date_time Date with the format &#39;%y-%m-%d %H:%M:%S&#39;, or a UNIX timestamp.
                      If the datetime is older than one day (default value for
                      tracking_requests_require_authentication_when_custom_timestamp_newer_than),
                      then you must call set_token_auth() with a valid Admin/Super user token.
        * @return self
        &#34;&#34;&#34;
        self.forcedDatetime = date_time
        return self

    def set_force_new_visit(self):
        &#34;&#34;&#34;
        Forces Matomo to create a new visit for the tracking request.

        By default, Matomo will create a new visit if the last request by this user was more than 30 minutes ago.
        If you call set_force_new_visit() before calling do_track*, then a new visit will be created for this request.
        * @return self
        &#34;&#34;&#34;
        self.forcedNewVisit = True
        return self

    def set_ip(self, ip):
        &#34;&#34;&#34;
        Overrides IP address

        Allowed only for Admin/Super User, must be used along with set_token_auth()
        * @see set_token_auth()
        * @param str ip IP string, eg. 130.54.2.1
        * @return self
        &#34;&#34;&#34;
        self.ip = ip
        return self

    def set_user_id(self, user_id):
        &#34;&#34;&#34;
        Force the action to be recorded for a specific User. The User ID is a string representing a given user in your system.

        A User ID can be a username, UUID or an email address, or any number or string that uniquely identifies a user or client.

        * @param str user_id Any user ID string (eg. email address, ID, username). Must be non empty. Set to False to de-assign a user id previously set.
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if user_id == &#34;&#34;:
            raise Exception(&#34;User ID cannot be empty.&#34;)
        self.user_id = user_id
        return self

    def get_user_id_hashed(self, id):
        &#34;&#34;&#34;
        Hash function used internally by Matomo to hash a User ID into the Visitor ID.

        Note: matches implementation of Tracker Request.get_user_id_hashed()

        * @param id
        * @return str
        &#34;&#34;&#34;
        return hashlib.sha1(id).hexdigest()[:16]

    def set_visitor_id(self, visitor_id):
        &#34;&#34;&#34;
        Forces the requests to be recorded for the specified Visitor ID.

        Rather than letting Matomo attribute the user with a heuristic based on IP and other user
        fingerprinting attributes, force the action to be recorded for a particular visitor.

        If not set, the visitor ID will be fetched from the 1st party cookie, or will be set to a random UUID.

        * @param str visitor_id 16 hexadecimal characters visitor ID, eg. &#34;33c31e01394bdc63&#34;
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        hex_chars = &#34;01234567890abcdefABCDEF&#34;
        if len(visitor_id) != self.LENGTH_VISITOR_ID or strspn(
            visitor_id, hex_chars
        ) != len(visitor_id):
            raise Exception(
                f&#34;set_visitor_id() expects a {self.LENGTH_VISITOR_ID} characters&#34;
                f&#34; hexadecimal string (containing only the following: {hex_chars})&#34;
            )
        self.forcedVisitorId = visitor_id
        return self

    def get_visitor_id(self):
        &#34;&#34;&#34;
        If the user initiating the request has the Matomo first party cookie, this function will try and
        return the ID parsed from this first party cookie (self, found in self.request.cookie):.

        If you call this function from a server, where the call is triggered by a cron or script
        not initiated by the actual visitor being tracked, then it will return
        the random Visitor ID that was assigned to this visit object.

        This can be used if you wish to record more visits, actions or goals for this visitor ID later on.

        * @return str 16 hex chars visitor ID string
        &#34;&#34;&#34;
        if self.forcedVisitorId:
            return self.forcedVisitorId
        if self.load_visitor_id_cookie():
            return self.cookieVisitorId
        return self.randomVisitorId

    def get_user_agent(self):
        &#34;&#34;&#34;
        Returns the currently set user agent.
        * @return str
        &#34;&#34;&#34;
        return self.user_agent

    def get_ip(self):
        &#34;&#34;&#34;
        Returns the currently set IP address.
        * @return str
        &#34;&#34;&#34;
        return self.ip

    def get_user_id(self):
        &#34;&#34;&#34;
        Returns the User ID string, which may have been set via:
            v.set_user_id(&#39;username@example.org&#39;)

        * @return bool
        &#34;&#34;&#34;
        return self.user_id

    def load_visitor_id_cookie(self):
        &#34;&#34;&#34;
        Loads values from the VisitorId Cookie

        * @return bool True if cookie exists and is valid, False otherwise
        &#34;&#34;&#34;
        id_cookie = self.get_cookie_matching_name(&#34;id&#34;)
        if not id_cookie:
            return False
        parts = id_cookie.split(&#34;.&#34;)
        if len(parts[0]) != self.LENGTH_VISITOR_ID:
            return False

        &#34;&#34;&#34; self.cookieVisitorId provides backward compatibility since get_visitor_id()
        didn&#39;t change any existing VisitorId value&#34;&#34;&#34;
        self.cookieVisitorId = parts[0]
        self.createTs = parts[1]
        return True

    def delete_cookies(self):
        &#34;&#34;&#34;
        Deletes all first party cookies from the client
        &#34;&#34;&#34;
        cookies = [&#34;id&#34;, &#34;ses&#34;, &#34;cvar&#34;, &#34;ref&#34;]
        for cookie in cookies:
            self.set_cookie(cookie, None, -86400)

    def get_attribution_info(self):
        &#34;&#34;&#34;
        Returns the currently assigned Attribution Information stored in a first party cookie.

        This function will only work if the user is initiating the current request, and his cookies
        can be read by Python from the self.request.cookie object.

        * @return str JSON Encoded string containing the Referrer information for Goal conversion attribution.
                       Will return False if the cookie could not be found
        * @see matomo.js get_attribution_info()
        &#34;&#34;&#34;
        if self.attributionInfo:
            return json.dumps(self.attributionInfo)

        return self.get_cookie_matching_name(&#34;ref&#34;)

    def set_token_auth(self, token_auth):
        &#34;&#34;&#34;
        Some Tracking API functionality requires express authentication, using either the
        Super User token_auth, or a user with &#39;admin&#39; access to the website.

        The following features require access:
        - force the visitor IP
        - force the date &amp; time of the tracking requests rather than track for the current datetime

        * @param str token_auth token_auth 32 chars token_auth string
        * @return self
        &#34;&#34;&#34;
        self.token_auth = token_auth
        return self

    def set_local_time(self, t):
        &#34;&#34;&#34;
        Sets local visitor time

        * @param str t HH:MM:SS format
        * @return self
        &#34;&#34;&#34;
        hour, minute, second = t.split(&#34;:&#34;)
        self.local_hour = hour
        self.local_minute = minute
        self.local_second = second
        return self

    def set_resolution(self, width, height):
        &#34;&#34;&#34;
        Sets user resolution width and height.

        * @param int width
        * @param int height
        * @return self
        &#34;&#34;&#34;
        self.width = width
        self.height = height
        return self

    def set_browser_has_cookies(self, b):
        &#34;&#34;&#34;
        Sets if the browser supports cookies
        This is reported in &#34;List of plugins&#34; report in Matomo.

        * @param bool b
        * @return self
        &#34;&#34;&#34;
        self.hasCookies = b
        return self

    def set_debug_string_append(self, string):
        &#34;&#34;&#34;
        Will append a custom string at the end of the Tracking request.
        * @param str string
        * @return self
        &#34;&#34;&#34;
        self.DEBUG_APPEND_URL = &#34;&amp;&#34; + string
        return self

    def set_plugins(
        self,
        flash=False,
        java=False,
        quick_time=False,
        real_player=False,
        pdf=False,
        windows_media=False,
        silverlight=False,
    ):
        &#34;&#34;&#34;
        Sets visitor browser supported plugins

        * @param bool flash
        * @param bool java
        * @param bool quick_time
        * @param bool real_player
        * @param bool pdf
        * @param bool windows_media
        * @param bool silverlight
        * @return self
        &#34;&#34;&#34;
        plugins = (
            f&#34;&amp;fla={int(flash)}&amp;java={int(java)}&amp;qt={int(quick_time)}&#34;
            f&#34;&amp;realp={int(real_player)}&amp;pdf={int(pdf)}&amp;wma={int(windows_media)}&amp;ag={int(silverlight)}&#34;
        )
        self.plugins = plugins
        return self

    def disable_cookie_support(self):
        &#34;&#34;&#34;
        By default, MatomoTracker will read first party cookies
        from the request and write updated cookies in the response (using setrawcookie).
        This can be disabled by calling this function.
        &#34;&#34;&#34;
        self.configCookiesDisabled = True

    def get_request_timeout(self):
        &#34;&#34;&#34;
        Returns the maximum number of seconds the tracker will spend waiting for a response
        from Matomo. Defaults to 600 seconds.
        &#34;&#34;&#34;
        return self.requestTimeout

    def set_request_timeout(self, timeout):
        &#34;&#34;&#34;
        Sets the maximum number of seconds that the tracker will spend waiting for a response
        from Matomo.

        * @param int timeout
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if not is_int(timeout) or timeout &lt; 0:
            raise Exception(&#34;Invalid value supplied for request timeout: timeout&#34;)

        self.requestTimeout = timeout
        return self

    def set_request_method_non_bulk(self, method):
        &#34;&#34;&#34;
        Sets the request method to POST, which is recommended when using set_token_auth()
        to prevent the token from being recorded in server logs. Avoid using redirects
        when using POST to prevent the loss of POST values. When using Log Analytics,
        be aware that POST requests are not parseable/replayable.

        * @param str method. Either &#39;POST&#39; or &#39;get&#39;
        * @return self
        &#34;&#34;&#34;
        self.request_method = &#34;POST&#34; if method.upper() == &#34;POST&#34; else &#34;GET&#34;
        return self

    def set_proxy(self, proxy, proxy_port=80, proxy_type=&#34;https&#34;):
        &#34;&#34;&#34;
        If a proxy is needed to look up the address of the Matomo site, set it with this
        * @param str proxy IP as string, for example &#34;173.234.92.107&#34;
        * @param int proxy_port
        &#34;&#34;&#34;
        self.proxy = proxy
        self.proxy_port = proxy_port
        self.proxy_type = proxy_type

    def get_proxy(self):
        &#34;&#34;&#34;
        If the proxy IP,the proxy port and the proxy_type have been set,
        with the set_proxy() function returns a string, like &#34;https://173.234.92.107:80&#34;
        &#34;&#34;&#34;
        if self.proxy and self.proxy_port and self.proxy_type:
            return f&#34;{self.proxy_type}://{self.proxy}:{self.proxy_port}&#34;
        return None

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    def send_request(self, url, method=&#34;get&#34;, data=None, force=False):
        raise NotImplementedError(&#34;Missing send_request implementation&#34;)

    def get_timestamp(self):
        &#34;&#34;&#34;
        Returns current timestamp, or forced timestamp/datetime if it was set
        * @return str|int
        &#34;&#34;&#34;
        if self.forcedDatetime:
            return datetime.strptime(self.forcedDatetime, &#34;%Y-%m-%d %H:%M:%S&#34;).timestamp()
        else:
            return time.time()

    def get_base_url(self):
        &#34;&#34;&#34;
        Returns the base URL for the Matomo server.
        &#34;&#34;&#34;
        if not self.URL:
            raise Exception(
                (
                    &#34;You must first set the Matomo Tracker URL by calling &#34;
                    &#34;MatomoTracker.URL = &#39;http://your-website.org/matomo/&#39;&#34;
                )
            )
        if (
            strpos(self.URL, &#34;/matomo.php&#34;) is False
            and strpos(self.URL, &#34;/proxy-matomo.php&#34;) is False
        ):
            self.URL = self.URL.rstrip(&#34;/&#34;)
            self.URL += &#34;/matomo.php&#34;

        return self.URL

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    def get_request(self, id_site):
        self.set_first_party_cookies()

        custom_fields = &#34;&#34;
        if self.customParameters:
            custom_fields = &#34;&amp;&#34; + urlencode_plus(self.customParameters)

        custom_dimensions = &#34;&#34;
        if self.customDimensions:
            custom_dimensions = &#34;&amp;&#34; + urlencode_plus(self.customDimensions)

        base_url = self.get_base_url()
        start = &#34;?&#34;
        if strpos(base_url, &#34;?&#34;):
            start = &#34;&amp;&#34;

        url = (
            f&#34;{base_url}{start}idsite={id_site}&amp;rec=1&amp;apiv={self.VERSION}&#34;
            + f&#34;&amp;r={str(random.randint(0, 2147483647))[2:8]}&#34;
            + (f&#34;&amp;cip={self.ip}&#34; if self.ip and self.token_auth else &#34;&#34;)
            + (f&#34;&amp;uid={urlencode_plus(self.user_id)}&#34; if self.user_id else &#34;&#34;)
            + (&#34;&amp;cdt=&#34; + urlencode_plus(self.forcedDatetime) if self.forcedDatetime else &#34;&#34;)
            + (&#34;&amp;new_visit=1&#34; if self.forcedNewVisit else &#34;&#34;)
            + f&#34;&amp;_idts={self.createTs}{self.plugins}&#34;
            + (
                f&#34;&amp;h={self.local_hour}&amp;m={self.local_minute}&amp;s={self.local_second}&#34;
                if self.local_hour and self.local_minute and self.local_second
                else &#34;&#34;
            )
            + (
                f&#34;&amp;res={self.width}x{self.height}&#34;
                if self.width and self.height
                else &#34;&#34;
            )
            + (f&#34;&amp;cookie={self.hasCookies}&#34; if self.hasCookies else &#34;&#34;)
            + (f&#34;&amp;data={self.customData}&#34; if self.customData else &#34;&#34;)
            + (
                &#34;&amp;_cvar=&#34; + urlencode_plus(json.dumps(self.visitorCustomVar))
                if self.visitorCustomVar
                else &#34;&#34;
            )
            + (
                &#34;&amp;cvar=&#34; + urlencode_plus(json.dumps(self.pageCustomVar))
                if self.pageCustomVar
                else &#34;&#34;
            )
            + (
                &#34;&amp;e_cvar=&#34; + urlencode_plus(json.dumps(self.eventCustomVar))
                if self.eventCustomVar
                else &#34;&#34;
            )
            + (
                f&#34;&amp;cid={self.forcedVisitorId}&#34;
                if self.forcedVisitorId
                else f&#34;&amp;_id={self.get_visitor_id()}&#34;
            )
            + &#34;&amp;url=&#34; + urlencode_plus(self.pageUrl)
            + &#34;&amp;urlref=&#34; + urlencode_plus(self.urlReferrer)
            + (
                f&#34;&amp;cs={self.pageCharset}&#34;
                if (
                    self.pageCharset
                    and self.pageCharset != self.DEFAULT_CHARSET_PARAMETER_VALUES
                )
                else &#34;&#34;
            )
            + (f&#34;&amp;pv_id={urlencode_plus(self.idPageview)}&#34; if self.idPageview else &#34;&#34;)
            + (
                &#34;&amp;_rcn=&#34; + urlencode_plus(self.attributionInfo[0])
                if self.attributionInfo and self.attributionInfo[0]
                else &#34;&#34;
            )
            + (
                &#34;&amp;_rck=&#34; + urlencode_plus(self.attributionInfo[1])
                if self.attributionInfo and self.attributionInfo[1]
                else &#34;&#34;
            )
            + (&#34;&amp;_refts=&#34; + self.attributionInfo[2] if self.attributionInfo and self.attributionInfo[2] else &#34;&#34;)
            + (
                &#34;&amp;_ref=&#34; + urlencode_plus(self.attributionInfo[3])
                if self.attributionInfo and self.attributionInfo[3]
                else &#34;&#34;
            )
            + (f&#34;&amp;country={urlencode_plus(self.country)}&#34; if self.country else &#34;&#34;)
            + (f&#34;&amp;region={urlencode_plus(self.region)}&#34; if self.region else &#34;&#34;)
            + (f&#34;&amp;city={urlencode_plus(self.city)}&#34;  if self.city else &#34;&#34;)
            + (f&#34;&amp;lat={urlencode_plus(str(self.lat))}&#34; if self.lat else &#34;&#34;)
            + (f&#34;&amp;long={urlencode_plus(str(self.long))}&#34; if self.long else &#34;&#34;)
            + custom_fields
            + custom_dimensions
            + (&#34;&amp;send_image=0&#34; if not self.sendImageResponse else &#34;&#34;)
            + self.DEBUG_APPEND_URL
        )

        if self.idPageview:
            url += (
                (f&#34;&amp;pf_net={self.networkTime}&#34; if self.networkTime else &#34;&#34;)
                + (f&#34;&amp;pf_srv={self.serverTime}&#34; if self.serverTime else &#34;&#34;)
                + (f&#34;&amp;pf_tfr={self.transferTime}&#34; if self.transferTime else &#34;&#34;)
                + (f&#34;&amp;pf_dm1={self.domProcessingTime}&#34; if self.domProcessingTime else &#34;&#34;)
                + (f&#34;&amp;pf_dm2={self.domCompletionTime}&#34; if self.domCompletionTime else &#34;&#34;)
                + (f&#34;&amp;pf_onl={self.onLoadTime}&#34; if self.onLoadTime else &#34;&#34;)
            )
            self.clear_performance_timings()

        for key in self.ecommerceView:
            url += f&#34;&amp;{key}={urlencode_plus(self.ecommerceView[key])}&#34;

        # Reset page level custom variables after this page view
        self.ecommerceView = {}
        self.pageCustomVar = {}
        self.eventCustomVar = {}
        self.clear_custom_dimensions()
        self.clear_custom_tracking_parameters()

        # force new visit only once, user must call again set_force_new_visit()
        self.forcedNewVisit = False

        return url

    def get_cookie_matching_name(self, name):
        &#34;&#34;&#34;
        Returns a first party cookie which name contains name

        * @param str name
        * @return str String value of cookie, or None if not found
        * @ignore
        &#34;&#34;&#34;
        if self.configCookiesDisabled or not self.request.cookie.get_dict():
            return None
        name = self.get_cookie_name(name)

        # Matomo cookie names use dots separators in matomo.js,
        # but PHP Replaces + with _ http://www.php.net/manual/en/language.variables.predefined.php#72571
        name = name.replace(&#34;.&#34;, &#34;_&#34;)
        for cookie_name, cookie_value in self.request.cookie.items():
            if strpos(name, cookie_name) is not False:  # 0 is fine
                return cookie_value

        return None

    def get_current_script_name(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;/dir1/dir2/index.php&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        url = &#34;&#34;
        if self.request.get(&#34;PATH_INFO&#34;):
            url = self.request.get(&#34;PATH_INFO&#34;)
        elif self.request.get(&#34;REQUEST_URI&#34;):
            url = self.request.get(&#34;REQUEST_URI&#34;, &#34;&#34;).split(&#34;?&#34;)[0]

        if not url:
            # Use if-else instead of get with default to correctly handle empty values
            if self.request.get(&#34;SCRIPT_NAME&#34;):
                url = self.request.get(&#34;SCRIPT_NAME&#34;)
            else:
                url = &#34;/&#34;

        if url and url[0] != &#34;/&#34;:
            url = &#34;/&#34; + url

        return url

    def get_current_scheme(self):
        &#34;&#34;&#34;
        If the current URL is &#39;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#39;http&#39;

        * @return str &#39;https&#39; or &#39;http&#39;
        * @ignore
        &#34;&#34;&#34;
        if &#34;HTTPS&#34; in self.request and (
            self.request.get(&#34;HTTPS&#34;) == &#34;on&#34; or self.request.get(&#34;HTTPS&#34;) is True
        ):
            return &#34;https&#34;
        return &#34;http&#34;

    def get_current_host(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;http://example.org&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        return self.request.get(&#34;HTTP_HOST&#34;, &#34;unknown&#34;)

    def get_current_query_string(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;?param1=value1&amp;param2=value2&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        url = &#34;&#34;
        if self.request.get(&#34;QUERY_STRING&#34;):
            url += &#34;?&#34; + self.request.get(&#34;QUERY_STRING&#34;)
        return url

    def get_current_url(self):
        &#34;&#34;&#34;
        Returns the current full URL (scheme, host, path and query string.

        * @return str
        * @ignore
        &#34;&#34;&#34;
        return &#34;&#34;.join(
            [
                self.get_current_scheme(),
                &#34;://&#34;,
                self.get_current_host(),
                self.get_current_script_name(),
                self.get_current_query_string(),
            ]
        )

    def set_first_party_cookies(self):
        &#34;&#34;&#34;
        Sets the first party cookies as would the matomo.js
        All cookies are supported: &#39;id&#39; and &#39;ses&#39; and &#39;ref&#39; and &#39;cvar&#39; cookies.
        * @return self
        &#34;&#34;&#34;
        if self.configCookiesDisabled:
            return self

        if self.cookieVisitorId:
            self.load_visitor_id_cookie()

        # Set the &#39;ref&#39; cookie
        attribution_info = self.get_attribution_info()
        if attribution_info:
            self.set_cookie(&#34;ref&#34;, attribution_info, self.configReferralCookieTimeout)

        # Set the &#39;ses&#39; cookie
        self.set_cookie(&#34;ses&#34;, &#34;*&#34;, self.configSessionCookieTimeout)

        # Set the &#39;id&#39; cookie
        cookie_value = f&#34;{self.get_visitor_id()}.{self.createTs}&#34;
        self.set_cookie(&#34;id&#34;, cookie_value, self.configVisitorCookieTimeout)

        # Set the &#39;cvar&#39; cookie
        self.set_cookie(
            &#34;cvar&#34;, json.dumps(self.visitorCustomVar), self.configSessionCookieTimeout
        )
        return self

    def _set_cookie(self, cookie_name, cookie_value, cookie_ttl):
        &#34;&#34;&#34;
        Sets a first party cookie to the client to improve dual JS-Python tracking.

        This replicates the matomo.js tracker algorithms for consistency and better accuracy.

        * @param cookie_name
        * @param cookie_value
        * @param cookie_ttl
        * @return self
        &#34;&#34;&#34;
        cookie_expire = self.currentTs + cookie_ttl
        cookie_header = (
            f&#34;Set-Cookie: {urlencode_plus(cookie_name)}={urlencode_plus(cookie_value)}&#34;
            (f&#34;; expires=&#39;{time.strftime(&#39;%a, %d-%m-%Y %H:%M:%S&#39;, cookieExpire)} GMT&#34; if cookie_expire else &#34;&#34;)
            (f&#34;; path=&#39;{self.configCookiePath}&#34; if self.configCookiePath else &#34;&#34;)
            (f&#34;; domain=&#39;{self.configCookieDomain}&#34; if self.configCookieDomain else &#34;&#34;)
            (f&#34;; secure&#34; if self.configCookieSecure else &#34;&#34;)
            (f&#34;; HttpOnly&#34; if self.configCookieHTTPOnly else &#34;&#34;)
            (f&#34;; SameSite={urlencode_plus(self.configCookieSameSite)}&#34; if self.configCookieSameSite else &#34;&#34;)
        )
        return cookie_header

    def set_cookie(self, cookie_name, cookie_value, cookie_ttl):
        &#34;&#34;&#34;
        Sets a first party cookie to the client to improve dual JS-Python tracking.

        This replicates the matomo.js tracker algorithms for consistency and better accuracy.

        * @param cookie_name
        * @param cookie_value
        * @param cookie_ttl
        * @return self
        &#34;&#34;&#34;
        cookie_expire = self.currentTs + cookie_ttl
        self.request.cookie.set(cookie_name, cookie_value, expires=cookie_expire)
        return self

    def get_cookies(self):
        return self.request.cookie

    def get_custom_variables_from_cookie(self):
        &#34;&#34;&#34;
        * @return bool|mixed
        &#34;&#34;&#34;
        cookie = self.get_cookie_matching_name(&#34;cvar&#34;)
        if not cookie:
            return False

        return json.loads(cookie)

    def set_outgoing_tracker_cookie(self, name, value=None):
        &#34;&#34;&#34;
        Sets a cookie to be sent to the tracking server.

        * @param name
        * @param value
        &#34;&#34;&#34;
        if value is None:
            del self.outgoingTrackerCookies[name]
        else:
            self.outgoingTrackerCookies[name] = value

    def get_incoming_tracker_cookie(self, name):
        &#34;&#34;&#34;
        Gets a cookie which was set by the tracking server.

        * @param name

        * @return bool|string
        &#34;&#34;&#34;
        return self.incomingTrackerCookies.get(name, False)

    def parse_incoming_cookies(self, headers):
        &#34;&#34;&#34;
        Reads incoming tracking server cookies.

        * @param array headers Array with HTTP response headers as values
        &#34;&#34;&#34;
        self.incomingTrackerCookies = {}

        if headers:
            header_name = &#34;set-cookie:&#34;
            header_name_length = len(header_name)

            for header in headers:
                if strpos(header.lower(), header_name) != 0:
                    continue
                cookies = header[header_name_length:].strip()
                pos_end = strpos(cookies, &#34;;&#34;)
                if pos_end is not False:  # 0 != False
                    cookies = cookies[:pos_end]
                self.incomingTrackerCookies = parse_qs(cookies)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.matomo.tracker.is_dict"><code class="name flex">
<span>def <span class="ident">is_dict</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">is_dict = lambda x: isinstance(x, dict)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.is_int"><code class="name flex">
<span>def <span class="ident">is_int</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">is_int = lambda x: isinstance(x, int)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.is_list"><code class="name flex">
<span>def <span class="ident">is_list</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">is_list = lambda x: isinstance(x, list)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.is_numeric"><code class="name flex">
<span>def <span class="ident">is_numeric</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">is_numeric = lambda x: isinstance(x, float)  # Used only once with float parameter</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.strpos"><code class="name flex">
<span>def <span class="ident">strpos</span></span>(<span>s, sub)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">strpos = lambda s, sub: s.find(sub) if s.find(sub) != -1 else False</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.strspn"><code class="name flex">
<span>def <span class="ident">strspn</span></span>(<span>str1, str2, start=0, length=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strspn(str1, str2, start=0, length=None):
    if not length:
        length = len(str1)
    return len(re.search(&#34;^[&#34; + str2 + &#34;]*&#34;, str1[start : start + length]).group(0))</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.urlencode_plus"><code class="name flex">
<span>def <span class="ident">urlencode_plus</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def urlencode_plus(s):
    if type(s) == str:
        return quote(s)
    elif type(s) == dict:
        return urlencode(s)
    else:
        raise TypeError(&#34;urlencode_plus works only on strings and dicts.&#34;, s)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.matomo.tracker.MatomoTracker"><code class="flex name class">
<span>class <span class="ident">MatomoTracker</span></span>
<span>(</span><span>request, id_site, api_url='')</span>
</code></dt>
<dd>
<div class="desc"><p>MatomoTracker implements the Matomo Tracking Web API.</p>
<p>For more information, see: <a href="https://github.com/matomo-org/matomo-php-tracker/">https://github.com/matomo-org/matomo-php-tracker/</a></p>
<ul>
<li>@package MatomoTracker</li>
<li>@api</li>
</ul>
<p>Builds a MatomoTracker object, used to track visits, pages and Goal conversions
for a specific website, by using the Matomo Tracking API.</p>
<ul>
<li>@param int id_site Id site to be tracked</li>
<li>@param str api_url "http://example.org/matomo/" or "http://matomo.example.org/"
If set, will overwrite MatomoTracker.URL</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatomoTracker:
    &#34;&#34;&#34;
    MatomoTracker implements the Matomo Tracking Web API.

    For more information, see: https://github.com/matomo-org/matomo-php-tracker/

    * @package MatomoTracker
    * @api
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    Matomo base URL, for example http://example.org/matomo/
    Must be set before using the class by calling
    MatomoTracker.URL = &#39;http://yourwebsite.org/matomo/&#39;

    * @var str
    &#34;&#34;&#34;
    URL = &#34;&#34;

    &#34;&#34;&#34;
    API Version

    * @ignore
    * @var int
    &#34;&#34;&#34;
    VERSION = 1

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    DEBUG_APPEND_URL = &#34;&#34;

    &#34;&#34;&#34;
    Visitor ID length

    * @ignore
    &#34;&#34;&#34;
    LENGTH_VISITOR_ID = 16

    &#34;&#34;&#34;
    Charset
    * @see set_page_charset
    * @ignore
    &#34;&#34;&#34;
    DEFAULT_CHARSET_PARAMETER_VALUES = &#34;utf-8&#34;

    &#34;&#34;&#34;
    See matomo.js
    &#34;&#34;&#34;
    FIRST_PARTY_COOKIES_PREFIX = &#34;_pk_&#34;

    &#34;&#34;&#34;
    Defines how many categories can be used max when calling add_ecommerce_item().
    * @var int
    &#34;&#34;&#34;
    MAX_NUM_ECOMMERCE_ITEM_CATEGORIES = 5

    DEFAULT_COOKIE_PATH = &#34;/&#34;

    def __init__(self, request, id_site, api_url=&#34;&#34;):
        &#34;&#34;&#34;
        Builds a MatomoTracker object, used to track visits, pages and Goal conversions
        for a specific website, by using the Matomo Tracking API.

        * @param int id_site Id site to be tracked
        * @param str api_url &#34;http://example.org/matomo/&#34; or &#34;http://matomo.example.org/&#34;
                                If set, will overwrite MatomoTracker.URL
        &#34;&#34;&#34;
        self.request = request
        self.request_method = &#34;GET&#34;
        self.ecommerceItems = []
        self.attributionInfo = []
        self.eventCustomVar = {}
        self.forcedDatetime = &#34;&#34;
        self.forcedNewVisit = False
        self.networkTime = 0
        self.serverTime = 0
        self.transferTime = 0
        self.domProcessingTime = 0
        self.domCompletionTime = 0
        self.onLoadTime = 0
        self.pageCustomVar = {}
        self.ecommerceView = {}
        self.customParameters = {}
        self.customDimensions = {}
        self.customData = &#34;&#34;
        self.hasCookies = False
        self.token_auth = &#34;&#34;
        self.user_agent = &#34;&#34;
        self.country = &#34;&#34;
        self.region = &#34;&#34;
        self.city = &#34;&#34;
        self.lat = 0.0
        self.long = 0.0
        self.width = 0
        self.height = 0
        self.plugins = &#34;&#34;
        self.local_hour = &#34;&#34;
        self.local_minute = &#34;&#34;
        self.local_second = &#34;&#34;
        self.idPageview = &#34;&#34;

        self.id_site = str(id_site)
        self.urlReferrer = self.request.get(&#34;HTTP_REFERER&#34;, &#34;&#34;)
        self.pageCharset = self.DEFAULT_CHARSET_PARAMETER_VALUES
        self.pageUrl = self.get_current_url()
        self.ip = self.request.get(&#34;REMOTE_ADDR&#34;, &#34;&#34;)
        self.accept_language = self.request.get(&#34;HTTP_ACCEPT_LANGUAGE&#34;, &#34;&#34;)
        self.user_agent = self.request.get(&#34;HTTP_USER_AGENT&#34;, &#34;&#34;)
        if api_url:
            self.URL = api_url

        # Life of the visitor cookie (in sec)
        self.configVisitorCookieTimeout = 33955200
        # 13 months (365 + 28 days)
        # Life of the session cookie (in sec)
        self.configSessionCookieTimeout = 1800
        # 30 minutes
        # Life of the session cookie (in sec)
        self.configReferralCookieTimeout = 15768000
        # 6 months

        # Visitor Ids in order
        self.user_id = &#34;&#34;
        self.forcedVisitorId = &#34;&#34;
        self.cookieVisitorId = &#34;&#34;
        self.randomVisitorId = &#34;&#34;

        self.set_new_visitor_id()

        self.configCookiesDisabled = False
        self.configCookiePath = self.DEFAULT_COOKIE_PATH
        self.configCookieDomain = &#34;&#34;
        self.configCookieSameSite = &#34;&#34;
        self.configCookieSecure = False
        self.configCookieHTTPOnly = False

        self.currentTs = time.time()
        self.createTs = self.currentTs

        # Allow debug while blocking the request
        self.requestTimeout = 600
        self.doBulkRequests = False
        self.storedTrackingActions = []

        self.sendImageResponse = True

        self.visitorCustomVar = self.get_custom_variables_from_cookie()

        self.outgoingTrackerCookies = {}
        self.incomingTrackerCookies = {}

        self.headersSent = False

        self.proxy = &#34;&#34;
        self.proxy_port = &#34;&#34;
        self.proxy_type = &#34;https&#34;

    def set_page_charset(self, charset=&#34;&#34;):
        &#34;&#34;&#34;
        By default, Matomo expects utf-8 encoded values, for example
        for the page URL parameter values, Page Title, etc.
        It is recommended to only send UTF-8 data to Matomo.
        If required though, you can also specify another charset using this function.

        * @param str charset
        * @return self
        &#34;&#34;&#34;
        self.pageCharset = charset
        return self

    def set_url(self, url):
        &#34;&#34;&#34;
        Sets the current URL being tracked

        * @param str url Raw URL (not URL encoded)
        * @return self
        &#34;&#34;&#34;
        self.pageUrl = url
        return self

    def set_url_referrer(self, url):
        &#34;&#34;&#34;
        Sets the URL referrer used to track Referrers details for new visits.

        * @param str url Raw URL (not URL encoded)
        * @return self
        &#34;&#34;&#34;
        self.urlReferrer = url
        return self

    def set_generation_time(self, time_ms):
        &#34;&#34;&#34;
        This method is deprecated and does nothing. It used to set the time that it took to generate the document on the server side.

        * @param int time_ms Generation time in ms
        * @return self

        * @deprecated this metric is deprecated please use performance timings instead
        * @see setPerformanceTimings
        &#34;&#34;&#34;
        return self

    def set_performance_timings(self, network=0, server=0, transfer=0, domProcessing=0, domCompletion=0, onLoad=0):
        &#34;&#34;&#34;
        Sets timings for various browser performance metrics.
        * @see https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming

        * @param int network Network time in ms (connectEnd – fetchStart)
        * @param int server Server time in ms (responseStart – requestStart)
        * @param int transfer Transfer time in ms (responseEnd – responseStart)
        * @param int domProcessing DOM Processing to Interactive time in ms (domInteractive – domLoading)
        * @param int domCompletion DOM Interactive to Complete time in ms (domComplete – domInteractive)
        * @param int onload Onload time in ms (loadEventEnd – loadEventStart)
        * @return self
        &#34;&#34;&#34;
        self.networkTime = network
        self.serverTime = server
        self.transferTime = transfer
        self.domProcessingTime = domProcessing
        self.domCompletionTime = domCompletion
        self.onLoadTime = onLoad
        return self

    def clear_performance_timings(self):
        &#34;&#34;&#34;
        Clear / reset all previously set performance metrics.
        &#34;&#34;&#34;
        self.networkTime = 0
        self.serverTime = 0
        self.transferTime = 0
        self.domProcessingTime = 0
        self.domCompletionTime = 0
        self.onLoadTime = 0

    def set_url_referer(self, url):
        &#34;&#34;&#34;
        * @deprecated
        * @ignore
        &#34;&#34;&#34;
        self.set_url_referrer(url)
        return self

    def set_attribution_info(self, json_encoded):
        &#34;&#34;&#34;
        Sets the attribution information to the visit, so that subsequent Goal conversions are
        properly attributed to the right Referrer URL, timestamp, Campaign Name &amp; Keyword.

        This must be a JSON encoded string that would typically be fetched from the JS API:
        matomoTracker.get_attribution_info() and that you have JSON encoded via JSON2.stringify()

        If you call enable_cookies() then these referral attribution values will be set
        to the &#39;ref&#39; first party cookie storing referral information.

        * @param str json_encoded JSON encoded list containing Attribution info
        * @return self
        * @throws Exception
        * @see def getAttributionInfo(self): in https://github.com/matomo-org/matomo/blob/master/js/matomo.js
        &#34;&#34;&#34;
        decoded = json.loads(json_encoded)
        if not is_list(decoded):
            raise Exception(
                f&#34;set_attribution_info() is expecting a JSON encoded string, &#39;{json_encoded}&#39; given&#34;
            )
        self.attributionInfo = decoded
        return self

    def set_custom_variable(self, id, name, value, scope=&#34;visit&#34;):
        &#34;&#34;&#34;
        Sets Visit Custom Variable.
        See https://matomo.org/docs/custom-variables/

        * @param int id Custom variable slot ID from 1-5
        * @param str name Custom variable name
        * @param str value Custom variable value
        * @param str scope Custom variable scope. Possible values: visit, page, event
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if not is_int(id):
            raise Exception(&#34;Parameter id to set_custom_variable should be an integer&#34;)
        if scope == &#34;page&#34;:
            self.pageCustomVar[id] = [name, value]
        elif scope == &#34;event&#34;:
            self.eventCustomVar[id] = [name, value]
        elif scope == &#34;visit&#34;:
            self.visitorCustomVar[id] = [name, value]
        else:
            raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
        return self

    def get_custom_variable(self, id, scope=&#34;visit&#34;):
        &#34;&#34;&#34;
        Returns the currently assigned Custom Variable.

        If scope is &#39;visit&#39;, it will attempt to read the value set in the first party cookie created by Matomo Tracker
         (self.request.cookie array).

        * @param int id Custom Variable integer index to fetch from cookie. Should be a value from 1 to 5
        * @param str scope Custom variable scope. Possible values: visit, page, event

        * @throws Exception
        * @return list A list with this format: [ CustomVariableName, CustomVariableValue ] or False
        * @see matomo.js getCustomVariable()
        &#34;&#34;&#34;
        if scope == &#34;page&#34;:
            return self.pageCustomVar.get(id, False)
        elif scope == &#34;event&#34;:
            return self.eventCustomVar.get(id, False)
        else:
            if scope != &#34;visit&#34;:
                raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
        if self.visitorCustomVar.get(id):
            return self.visitorCustomVar[id]

        cookie_decoded = self.get_custom_variables_from_cookie()
        if not is_int(id):
            raise Exception(&#34;Parameter to get_custom_variable should be an integer&#34;)
        if (
            not is_dict(cookie_decoded)
            or id not in cookie_decoded
            or not is_list(cookie_decoded[id])
            or len(cookie_decoded[id]) != 2
        ):
            return False

        return cookie_decoded[id]

    def clear_custom_variables(self):
        &#34;&#34;&#34;
        Clears any Custom Variable that may be have been set.

        This can be useful when you have enabled bulk requests,
        and you wish to clear Custom Variables of &#39;visit&#39; scope.
        &#34;&#34;&#34;
        self.visitorCustomVar = {}
        self.pageCustomVar = {}
        self.eventCustomVar = {}

    def set_custom_dimension(self, id, value):
        &#34;&#34;&#34;
        Sets a specific custom dimension

        * @param int id id of custom dimension
        * @param str value value for custom dimension
        * @return self
        &#34;&#34;&#34;
        self.customDimensions[f&#34;dimension{id}&#34;] = value
        return self

    def clear_custom_dimensions(self):
        &#34;&#34;&#34;
        Clears all previously set custom dimensions
        &#34;&#34;&#34;
        self.customDimensions = {}

    def get_custom_dimension(self, id):
        &#34;&#34;&#34;
        Returns the value of the custom dimension with the given id

        * @param int id id of custom dimension
        * @return str | None
        &#34;&#34;&#34;
        return self.customDimensions.get(f&#34;dimension{id}&#34;, None)

    def set_custom_tracking_parameter(self, tracking_api_parameter, value):
        &#34;&#34;&#34;
        Sets a custom tracking parameter. This is useful if you need to send any tracking parameters for a 3rd party
        plugin that is not shipped with Matomo itself. Please note that custom parameters are cleared after each
        tracking request.

        * @param str tracking_api_parameter The name of the tracking API parameter, eg &#39;bw_bytes&#39;
        * @param str value Tracking parameter value that shall be sent for this tracking parameter.
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        regex = re.compile(&#39;/^dimension([0-9]+)$/&#39;)
        matches = re.findall(regex, tracking_api_parameter)
        if len(matches):
            # Unlike PHP preg_match it returns captured subpattern as first element
            self.set_custom_dimension(matches[0], value)
            return self

        self.customParameters[tracking_api_parameter] = value
        return self

    def clear_custom_tracking_parameters(self):
        &#34;&#34;&#34;
        Clear / reset all previously set custom tracking parameters.
        &#34;&#34;&#34;
        self.customParameters = {}

    def set_new_visitor_id(self):
        &#34;&#34;&#34;
        Sets the current visitor ID to a random new one.
        * @return self
        &#34;&#34;&#34;
        self.randomVisitorId = uuid.uuid4().hex[: self.LENGTH_VISITOR_ID]
        self.forcedVisitorId = False
        self.cookieVisitorId = False
        return self

    def set_id_site(self, id_site):
        &#34;&#34;&#34;
        Sets the current site ID.

        * @param int id_site
        * @return self
        &#34;&#34;&#34;
        self.id_site = id_site
        return self

    def set_browser_language(self, accept_language):
        &#34;&#34;&#34;
        Sets the Browser language. Used to guess visitor countries when GeoIP is not enabled

        * @param str accept_language For example &#34;fr-fr&#34;
        * @return self
        &#34;&#34;&#34;
        self.accept_language = accept_language
        return self

    def set_user_agent(self, user_agent):
        &#34;&#34;&#34;
        Sets the user agent, used to detect OS and browser.
        If this function is not called, the User Agent will default to the current user agent.

        * @param str user_agent
        * @return self
        &#34;&#34;&#34;
        self.user_agent = user_agent
        return self

    def set_country(self, country):
        &#34;&#34;&#34;
        Sets the country of the visitor. If not used, Matomo will try to find the country
        using either the visitor&#39;s IP address or language.

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str country
        * @return self
        &#34;&#34;&#34;
        self.country = country
        return self

    def set_region(self, region):
        &#34;&#34;&#34;
        Sets the region of the visitor. If not used, Matomo may try to find the region
        using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str region
        * @return self
        &#34;&#34;&#34;
        self.region = region
        return self

    def set_city(self, city):
        &#34;&#34;&#34;
        Sets the city of the visitor. If not used, Matomo may try to find the city
        using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param str city
        * @return self
        &#34;&#34;&#34;
        self.city = city
        return self

    def set_latitude(self, lat):
        &#34;&#34;&#34;
        Sets the latitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
        latitude using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param float lat
        * @return self
        &#34;&#34;&#34;
        self.lat = lat
        return self

    def set_longitude(self, long):
        &#34;&#34;&#34;
        Sets the longitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
        longitude using the visitor&#39;s IP address (if configured to do so).

        Allowed only for Admin/Super User, must be used along with set_token_auth().
        * @param float long
        * @return self
        &#34;&#34;&#34;
        self.long = long
        return self

    def enable_bulk_tracking(self):
        &#34;&#34;&#34;
        Enables the bulk request feature. When used, each tracking action is stored until the
        do_bulk_track method is called. This method will send all tracking data at once.

        &#34;&#34;&#34;
        self.doBulkRequests = True

    def enable_cookies(
        self, domain=&#34;&#34;, path=&#34;/&#34;, secure=False, http_only=False, same_site=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Enable cookie creation - this will cause a first party VisitorId cookie to be set when the VisitorId is set or reset

        * @param str domain (optional) Set first-party cookie domain.
                    Accepted values: example.com, *.example.com (same as .example.com) or subdomain.example.com
        * @param str path (optional) Set first-party cookie path
        * @param bool secure (optional) Set secure flag for cookies
        * @param bool http_only (optional) Set HTTPOnly flag for cookies
        * @param str same_site (optional) Set SameSite flag for cookies
        &#34;&#34;&#34;
        self.configCookiesDisabled = False
        self.configCookieDomain = self.domain_fixup(domain)
        self.configCookiePath = path
        self.configCookieSecure = secure
        self.configCookieHTTPOnly = http_only
        self.configCookieSameSite = same_site

    def disable_send_image_response(self):
        &#34;&#34;&#34;
        If image response is disabled Matomo will respond with a HTTP 204 header instead of responding with a gif.
        &#34;&#34;&#34;
        self.sendImageResponse = False

    def domain_fixup(self, domain):
        &#34;&#34;&#34;
        Fix-up domain

        Remove trailing &#39;.&#39; and leading &#39;*.&#39;
        &#34;&#34;&#34;
        return domain.rstrip(&#34;.&#34;).lstrip(&#34;*.&#34;)

    def get_cookie_name(self, cookie_name):
        &#34;&#34;&#34;
        Get cookie name with prefix and domain hash
        * @param str cookie_name
        * @return str
        &#34;&#34;&#34;
        hash_string = hashlib.sha1(
            (
                self.get_current_host()
                if self.configCookieDomain == &#34;&#34;
                else self.configCookieDomain
            ).encode(&#34;utf-8&#34;)
            + self.configCookiePath.encode(&#34;utf-8&#34;)
        ).hexdigest()[:4]

        return &#34;{}{}.{}.{}&#34;.format(
            self.FIRST_PARTY_COOKIES_PREFIX,
            cookie_name,
            self.id_site,
            hash_string
        )

    def do_track_page_view(self, document_title):
        &#34;&#34;&#34;
        Tracks a page view

        * @param str document_title Page title as it will appear in the Actions &gt; Page titles report
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        self.generate_new_pageview_id()
        url = self.get_url_track_page_view(document_title)
        return self.send_request(url)

    def generate_new_pageview_id(self):
        self.idPageview = uuid.uuid4().hex[:6]

    def do_track_event(self, category, action, name=&#34;&#34;, value=0):
        &#34;&#34;&#34;
        Tracks an event

        * @param str category The Event Category (Videos, Music, Games...)
        * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
        * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
        * @param float value (optional) The Event&#39;s value
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_event(category, action, name, value)
        return self.send_request(url)

    def do_track_content_impression(
        self, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Tracks a content impression

        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str content_target (optional) The target of the content. For instance the URL of a landing page.
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_content_impression(
            content_name, content_piece, content_target
        )
        return self.send_request(url)

    def do_track_content_interaction(
        self, interaction, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
    ):
        &#34;&#34;&#34;
        Tracks a content interaction. Make sure you have tracked a content impression using the same content name and
        content piece, otherwise it will not count. To do so you should call the method do_track_content_impression()

        * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_content_interaction(
            interaction, content_name, content_piece, content_target
        )

        return self.send_request(url)

    def do_track_site_search(self, keyword, category=&#34;&#34;, count_results=0):
        &#34;&#34;&#34;
        Tracks an internal Site Search query, and optionally tracks the Search
        Category, and Search results Count.
        These are used to populate reports in Actions &gt; Site Search.

        * @param str keyword Searched query on the site
        * @param str category (optional) Search engine category if applicable
        * @param int count_results (optional) results displayed on the search
        result page. Used to track &#34;zero result&#34; keywords.

        * @return mixed Response string or True if using bulk requests.
        &#34;&#34;&#34;
        url = self.get_url_track_site_search(keyword, category, count_results)
        return self.send_request(url)

    def do_track_goal(self, id_goal, revenue=0.0):
        &#34;&#34;&#34;
        Records a Goal conversion

        * @param int id_goal Id Goal to record a conversion
        * @param float revenue Revenue for this conversion
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_goal(id_goal, revenue)
        return self.send_request(url)

    def do_track_action(self, action_url, action_type):
        &#34;&#34;&#34;
        Tracks a download or outlink

        * @param str action_url URL of the download or outlink
        * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        # Referrer could be updated to be the current URL temporarily (to mimic JS behavior)
        url = self.get_url_track_action(action_url, action_type)
        return self.send_request(url)

    def add_ecommerce_item(self, sku, name=&#34;&#34;, category=&#34;&#34;, price=0.0, quantity=1):
        &#34;&#34;&#34;
        Adds an item in the Ecommerce order.

        This should be called before do_track_ecommerce_order(), or before do_track_ecommerce_cart_update().
        This function can be called for all individual products in the cart (self, or order):.
        SKU parameter is mandatory. Other parameters are optional (set to False if value not known).
        Ecommerce items added via this function are automatically cleared when
        do_track_ecommerce_order() or get_url_track_ecommerce_order() is called.

        * @param str sku (required) SKU, Product identifier
        * @param str name (optional) Product name
        * @param str|list category (optional) Product category, or list of product categories (up to 5 categories can be specified for a given product)
        * @param float|int price (optional) Individual product price (supports integer and decimal prices)
        * @param int quantity (optional) Product quantity. If specified, will default to 1 not in the Reports
        * @throws Exception
        * @return self
        &#34;&#34;&#34;
        if not sku:
            raise Exception(&#34;You must specify a SKU for the Ecommerce item&#34;)

        price = self.force_dot_as_separator_for_decimal_point(price)
        self.ecommerceItems = [sku, name, category, price, quantity]
        return self

    def do_track_ecommerce_cart_update(self, grand_total):
        &#34;&#34;&#34;
        Tracks a Cart Update (add item, remove item, update item).

        On every Cart update, you must call add_ecommerce_item() for each item
        (product) in the cart, including the items that haven&#39;t been updated
        since the last cart update.
        Items which were in the previous cart and are sent not in later Cart
        updates will be deleted from the cart (in the database).

        * @param float grand_total Cart grand_total (typically the sum of all items&#39; prices)
        * @return mixed Response string or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce_cart_update(grand_total)
        return self.send_request(url)

    def do_bulk_track(self):
        &#34;&#34;&#34;
        Sends all stored tracking actions at once. Only has an effect if bulk tracking is enabled.

        To enable bulk tracking, call enable_bulk_tracking().

        * @throws Exception
        * @return str Response
        &#34;&#34;&#34;
        if not self.storedTrackingActions:
            raise Exception(
                (
                    &#34;Error: you must call the function do_track_page_view or do_track_goal&#34;
                    &#34; from this class, before calling this method do_bulk_track():&#34;
                )
            )

        data = {&#34;requests&#34;: self.storedTrackingActions}

        # token_auth is not required by default, except if bulk_requests_require_authentication=1
        if self.token_auth:
            data[&#34;token_auth&#34;] = self.token_auth

        post_data = json.dumps(data)
        response = self.send_request(self.get_base_url(), &#34;POST&#34;, post_data, force=True)

        self.storedTrackingActions = []

        return response

    def do_track_ecommerce_order(
        self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Tracks an Ecommerce order.

        If the Ecommerce order contains items (products), you must call first the add_ecommerce_item() for each item in the order.
        All revenues (grand_total, sub_total, tax, shipping, discount) will be individually summed and reported in Matomo reports.
        Only the parameters order_id and grand_total are required.

        * @param str|int order_id (required) Unique Order ID.
                       This will be used to count this order only once in the event the order page is reloaded several times.
                       order_id must be unique for each transaction, even on different days, or the transaction will not be recorded by Matomo.
        * @param float grand_total (required) Grand Total revenue of the transaction (including tax, shipping, etc.)
        * @param float sub_total (optional) Sub total amount, typically the sum of items prices for all items in this order (before Tax and Shipping costs are applied)
        * @param float tax (optional) Tax amount for this order
        * @param float shipping (optional) Shipping amount for this order
        * @param float discount (optional) Discounted amount in this order
        * @return mixed Response or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce_order(
            order_id, grand_total, sub_total, tax, shipping, discount
        )
        return self.send_request(url)

    def do_ping(self):
        &#34;&#34;&#34;
        Sends a ping request.

        Ping requests do track new actions. If they are sent within the standard visit length (see global.ini.php), * they will extend the existing visit and the current last action for the visit. If after the standard visit length, * ping requests will create a new visit using the last action not in the last known visit.

        * @return mixed Response or True if using bulk request
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += &#34;&amp;ping=1&#34;

        return self.send_request(url)

    def set_ecommerce_view(self, sku=&#34;&#34;, name=&#34;&#34;, category=&#34;&#34;, price=0.0):
        &#34;&#34;&#34;
        Sets the current page view as an item (product) page view, or an Ecommerce Category page view.

        This must be called before do_track_page_view() on this product/category page.

        On a category page, you may set the parameter category only and set the other parameters to False.

        Tracking Product/Category page views will allow Matomo to report on Product &amp; Categories
        conversion rates (Conversion rate = Ecommerce orders containing this product or category / Visits to the product or category)

        * @param str sku Product SKU being viewed
        * @param str name Product Name being viewed
        * @param str|array category Category being viewed. On a Product page, this is the product&#39;s category.
                                       You can also specify an array of up to 5 categories for a given page view.
        * @param float price Specify the price at which the item was displayed
        * @return self
        &#34;&#34;&#34;
        self.ecommerceView = {}
        if category:
            if is_list(category):
                category = json.dumps(category)

        self.ecommerceView[&#34;_pkc&#34;] = category

        if price:
            price = str(price)
            price = self.force_dot_as_separator_for_decimal_point(price)
            self.ecommerceView[&#34;_pkp&#34;] = price

        # On a category page, do not record &#34;Product name not defined&#34;
        if not sku and not name:
            return self
        if sku:
            self.ecommerceView[&#34;_pks&#34;] = sku
        if not name:
            name = &#34;&#34;
        self.ecommerceView[&#34;_pkn&#34;] = name
        return self

    def force_dot_as_separator_for_decimal_point(self, value):
        &#34;&#34;&#34;
        Force the separator for decimal point to be a dot. See https://github.com/matomo-org/matomo/issues/6435
        If for instance a German locale is used it would be a comma otherwise.

        * @param  float|string value
        * @return str
        &#34;&#34;&#34;
        if value is None or value is False:
            return &#34;&#34;
        return str(value).replace(&#34;,&#34;, &#34;.&#34;)

    def get_url_track_ecommerce_cart_update(self, grand_total):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce Cart updates
        Calling this function will reinitialize the property ecommerceItems to empty list
        so items will have to be added again via add_ecommerce_item()
        * @ignore
        &#34;&#34;&#34;
        url = self.get_url_track_ecommerce(grand_total)
        return url

    def get_url_track_ecommerce_order(
        self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce Orders
        Calling this function will reinitialize the property ecommerceItems to empty list
        so items will have to be added again via add_ecommerce_item()
        * @ignore
        &#34;&#34;&#34;
        if not order_id:
            raise Exception(&#34;You must specify an order_id for the Ecommerce order&#34;)
        url = self.get_url_track_ecommerce(
            grand_total, sub_total, tax, shipping, discount
        )
        url += &#34;&amp;ec_id=&#34; + urlencode_plus(order_id)

        return url

    def get_url_track_ecommerce(
        self, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
    ):
        &#34;&#34;&#34;
        Returns URL used to track Ecommerce orders

        Calling this function will reinitialize the property ecommerceItems to empty array
        so items will have to be added again via add_ecommerce_item()

        * @ignore
        &#34;&#34;&#34;
        if not is_numeric(grand_total) and not is_int(grand_total):
            raise Exception(
                &#34;You must specify a grand_total for the Ecommerce order (or Cart update)&#34;
            )

        url = self.get_request(self.id_site)
        url += &#34;&amp;idgoal=0&#34;
        if grand_total:
            grand_total = self.force_dot_as_separator_for_decimal_point(grand_total)
            url += f&#34;&amp;revenue={grand_total}&#34;
        if sub_total:
            sub_total = self.force_dot_as_separator_for_decimal_point(sub_total)
            url += f&#34;&amp;ec_st={sub_total}&#34;
        if tax:
            tax = self.force_dot_as_separator_for_decimal_point(tax)
            url += f&#34;&amp;ec_tx={tax}&#34;
        if shipping:
            shipping = self.force_dot_as_separator_for_decimal_point(shipping)
            url += f&#34;&amp;ec_sh={shipping}&#34;
        if discount:
            discount = self.force_dot_as_separator_for_decimal_point(discount)
            url += f&#34;&amp;ec_dt={discount}&#34;
        if self.ecommerceItems:
            url += &#34;&amp;ec_items=&#34; + urlencode_plus(json.dumps(self.ecommerceItems))
        self.ecommerceItems = []

        return url

    def get_url_track_page_view(self, document_title=&#34;&#34;):
        &#34;&#34;&#34;
        Builds URL to track a page view.

        * @see do_track_page_view()
        * @param str document_title Page view name as it will appear in Matomo reports
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        if document_title:
            url += &#34;&amp;action_name=&#34; + urlencode_plus(document_title)
        return url

    def get_url_track_event(self, category, action, name=&#34;&#34;, value=0):
        &#34;&#34;&#34;
        Builds URL to track a custom event.

        * @see do_track_event()
        * @param str category The Event Category (Videos, Music, Games...)
        * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
        * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
        * @param float value (optional) The Event&#39;s value
        * @return str URL to matomo.php with all parameters set to track the pageview
        * @throws
        &#34;&#34;&#34;
        if not category:
            raise Exception(
                &#34;You must specify an Event Category name (Music, Videos, Games...).&#34;
            )
        if not action:
            raise Exception(&#34;You must specify an Event action (click, view, add...).&#34;)

        url = self.get_request(self.id_site)
        url += f&#34;&amp;e_c={urlencode_plus(category)}&amp;e_a={urlencode_plus(action)}&#34;

        if name:
            url += f&#34;&amp;e_n={urlencode_plus(name)}&#34;
        if value:
            value = self.force_dot_as_separator_for_decimal_point(value)
            url += f&#34;&amp;e_v={value}&#34;

        return url

    def get_url_track_content_impression(
        self, content_name, content_piece, content_target
    ):
        &#34;&#34;&#34;
        Builds URL to track a content impression.

        * @see do_track_content_impression()
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str|False content_target (optional) The target of the content. For instance the URL of a landing page.
        * @throws Exception In case content_name is empty
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)

        if not content_name:
            raise Exception(&#34;You must specify a content name&#34;)

        url += f&#34;&amp;c_n={urlencode_plus(content_name)}&#34;

        if content_piece:
            url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
        if content_target:
            url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

        return url

    def get_url_track_content_interaction(
        self, interaction, content_name, content_piece, content_target
    ):
        &#34;&#34;&#34;
        Builds URL to track a content impression.

        * @see do_track_content_interaction()
        * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
        * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
        * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
        * @param str|False content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
        * @throws Exception In case interaction or content_name is empty
        * @return str URL to matomo.php with all parameters set to track the pageview
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)

        if not interaction:
            raise Exception(&#34;You must specify a name for the interaction&#34;)

        if not content_name:
            raise Exception(&#34;You must specify a content name&#34;)

        url += f&#34;&amp;c_i={urlencode_plus(interaction)}&amp;c_n={urlencode_plus(content_name)}&#34;

        if content_piece:
            url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
        if content_target:
            url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

        return url

    def get_url_track_site_search(self, keyword, category, count_results):
        &#34;&#34;&#34;
        Builds URL to track a site search.

        * @see do_track_site_search()
        * @param str keyword
        * @param str category
        * @param int count_results
        * @return str
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;search=&#34; + urlencode_plus(keyword)
        if category:
            url += f&#34;&amp;search_cat={urlencode_plus(category)}&#34;
        if count_results or count_results == 0:
            url += f&#34;&amp;search_count={count_results}&#34;

        return url

    def get_url_track_goal(self, id_goal, revenue=0.0):
        &#34;&#34;&#34;
        Builds URL to track a goal with id_goal and revenue.

        * @see do_track_goal()
        * @param int id_goal Id Goal to record a conversion
        * @param float revenue Revenue for this conversion
        * @return str URL to matomo.php with all parameters set to track the goal conversion
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;idgoal={id_goal}&#34;
        if revenue:
            revenue = self.force_dot_as_separator_for_decimal_point(revenue)
            url += f&#34;&amp;revenue={revenue}&#34;

        return url

    def get_url_track_action(self, action_url, action_type):
        &#34;&#34;&#34;
        Builds URL to track a new action.

        * @see do_track_action()
        * @param str action_url URL of the download or outlink
        * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
        * @return str URL to matomo.php with all parameters set to track an action
        &#34;&#34;&#34;
        url = self.get_request(self.id_site)
        url += f&#34;&amp;{action_type}={urlencode_plus(action_url)}&#34;
        return url

    def set_force_visit_date_time(self, date_time):
        &#34;&#34;&#34;
        Overrides server date and time for the tracking requests.
        By default Matomo will track requests for the &#34;current datetime&#34; but this function allows you
        to track visits in the past. All times are in UTC.

        Allowed only for Admin/Super User, must be used along with set_token_auth()
        * @see set_token_auth()
        * @param str date_time Date with the format &#39;%y-%m-%d %H:%M:%S&#39;, or a UNIX timestamp.
                      If the datetime is older than one day (default value for
                      tracking_requests_require_authentication_when_custom_timestamp_newer_than),
                      then you must call set_token_auth() with a valid Admin/Super user token.
        * @return self
        &#34;&#34;&#34;
        self.forcedDatetime = date_time
        return self

    def set_force_new_visit(self):
        &#34;&#34;&#34;
        Forces Matomo to create a new visit for the tracking request.

        By default, Matomo will create a new visit if the last request by this user was more than 30 minutes ago.
        If you call set_force_new_visit() before calling do_track*, then a new visit will be created for this request.
        * @return self
        &#34;&#34;&#34;
        self.forcedNewVisit = True
        return self

    def set_ip(self, ip):
        &#34;&#34;&#34;
        Overrides IP address

        Allowed only for Admin/Super User, must be used along with set_token_auth()
        * @see set_token_auth()
        * @param str ip IP string, eg. 130.54.2.1
        * @return self
        &#34;&#34;&#34;
        self.ip = ip
        return self

    def set_user_id(self, user_id):
        &#34;&#34;&#34;
        Force the action to be recorded for a specific User. The User ID is a string representing a given user in your system.

        A User ID can be a username, UUID or an email address, or any number or string that uniquely identifies a user or client.

        * @param str user_id Any user ID string (eg. email address, ID, username). Must be non empty. Set to False to de-assign a user id previously set.
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if user_id == &#34;&#34;:
            raise Exception(&#34;User ID cannot be empty.&#34;)
        self.user_id = user_id
        return self

    def get_user_id_hashed(self, id):
        &#34;&#34;&#34;
        Hash function used internally by Matomo to hash a User ID into the Visitor ID.

        Note: matches implementation of Tracker Request.get_user_id_hashed()

        * @param id
        * @return str
        &#34;&#34;&#34;
        return hashlib.sha1(id).hexdigest()[:16]

    def set_visitor_id(self, visitor_id):
        &#34;&#34;&#34;
        Forces the requests to be recorded for the specified Visitor ID.

        Rather than letting Matomo attribute the user with a heuristic based on IP and other user
        fingerprinting attributes, force the action to be recorded for a particular visitor.

        If not set, the visitor ID will be fetched from the 1st party cookie, or will be set to a random UUID.

        * @param str visitor_id 16 hexadecimal characters visitor ID, eg. &#34;33c31e01394bdc63&#34;
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        hex_chars = &#34;01234567890abcdefABCDEF&#34;
        if len(visitor_id) != self.LENGTH_VISITOR_ID or strspn(
            visitor_id, hex_chars
        ) != len(visitor_id):
            raise Exception(
                f&#34;set_visitor_id() expects a {self.LENGTH_VISITOR_ID} characters&#34;
                f&#34; hexadecimal string (containing only the following: {hex_chars})&#34;
            )
        self.forcedVisitorId = visitor_id
        return self

    def get_visitor_id(self):
        &#34;&#34;&#34;
        If the user initiating the request has the Matomo first party cookie, this function will try and
        return the ID parsed from this first party cookie (self, found in self.request.cookie):.

        If you call this function from a server, where the call is triggered by a cron or script
        not initiated by the actual visitor being tracked, then it will return
        the random Visitor ID that was assigned to this visit object.

        This can be used if you wish to record more visits, actions or goals for this visitor ID later on.

        * @return str 16 hex chars visitor ID string
        &#34;&#34;&#34;
        if self.forcedVisitorId:
            return self.forcedVisitorId
        if self.load_visitor_id_cookie():
            return self.cookieVisitorId
        return self.randomVisitorId

    def get_user_agent(self):
        &#34;&#34;&#34;
        Returns the currently set user agent.
        * @return str
        &#34;&#34;&#34;
        return self.user_agent

    def get_ip(self):
        &#34;&#34;&#34;
        Returns the currently set IP address.
        * @return str
        &#34;&#34;&#34;
        return self.ip

    def get_user_id(self):
        &#34;&#34;&#34;
        Returns the User ID string, which may have been set via:
            v.set_user_id(&#39;username@example.org&#39;)

        * @return bool
        &#34;&#34;&#34;
        return self.user_id

    def load_visitor_id_cookie(self):
        &#34;&#34;&#34;
        Loads values from the VisitorId Cookie

        * @return bool True if cookie exists and is valid, False otherwise
        &#34;&#34;&#34;
        id_cookie = self.get_cookie_matching_name(&#34;id&#34;)
        if not id_cookie:
            return False
        parts = id_cookie.split(&#34;.&#34;)
        if len(parts[0]) != self.LENGTH_VISITOR_ID:
            return False

        &#34;&#34;&#34; self.cookieVisitorId provides backward compatibility since get_visitor_id()
        didn&#39;t change any existing VisitorId value&#34;&#34;&#34;
        self.cookieVisitorId = parts[0]
        self.createTs = parts[1]
        return True

    def delete_cookies(self):
        &#34;&#34;&#34;
        Deletes all first party cookies from the client
        &#34;&#34;&#34;
        cookies = [&#34;id&#34;, &#34;ses&#34;, &#34;cvar&#34;, &#34;ref&#34;]
        for cookie in cookies:
            self.set_cookie(cookie, None, -86400)

    def get_attribution_info(self):
        &#34;&#34;&#34;
        Returns the currently assigned Attribution Information stored in a first party cookie.

        This function will only work if the user is initiating the current request, and his cookies
        can be read by Python from the self.request.cookie object.

        * @return str JSON Encoded string containing the Referrer information for Goal conversion attribution.
                       Will return False if the cookie could not be found
        * @see matomo.js get_attribution_info()
        &#34;&#34;&#34;
        if self.attributionInfo:
            return json.dumps(self.attributionInfo)

        return self.get_cookie_matching_name(&#34;ref&#34;)

    def set_token_auth(self, token_auth):
        &#34;&#34;&#34;
        Some Tracking API functionality requires express authentication, using either the
        Super User token_auth, or a user with &#39;admin&#39; access to the website.

        The following features require access:
        - force the visitor IP
        - force the date &amp; time of the tracking requests rather than track for the current datetime

        * @param str token_auth token_auth 32 chars token_auth string
        * @return self
        &#34;&#34;&#34;
        self.token_auth = token_auth
        return self

    def set_local_time(self, t):
        &#34;&#34;&#34;
        Sets local visitor time

        * @param str t HH:MM:SS format
        * @return self
        &#34;&#34;&#34;
        hour, minute, second = t.split(&#34;:&#34;)
        self.local_hour = hour
        self.local_minute = minute
        self.local_second = second
        return self

    def set_resolution(self, width, height):
        &#34;&#34;&#34;
        Sets user resolution width and height.

        * @param int width
        * @param int height
        * @return self
        &#34;&#34;&#34;
        self.width = width
        self.height = height
        return self

    def set_browser_has_cookies(self, b):
        &#34;&#34;&#34;
        Sets if the browser supports cookies
        This is reported in &#34;List of plugins&#34; report in Matomo.

        * @param bool b
        * @return self
        &#34;&#34;&#34;
        self.hasCookies = b
        return self

    def set_debug_string_append(self, string):
        &#34;&#34;&#34;
        Will append a custom string at the end of the Tracking request.
        * @param str string
        * @return self
        &#34;&#34;&#34;
        self.DEBUG_APPEND_URL = &#34;&amp;&#34; + string
        return self

    def set_plugins(
        self,
        flash=False,
        java=False,
        quick_time=False,
        real_player=False,
        pdf=False,
        windows_media=False,
        silverlight=False,
    ):
        &#34;&#34;&#34;
        Sets visitor browser supported plugins

        * @param bool flash
        * @param bool java
        * @param bool quick_time
        * @param bool real_player
        * @param bool pdf
        * @param bool windows_media
        * @param bool silverlight
        * @return self
        &#34;&#34;&#34;
        plugins = (
            f&#34;&amp;fla={int(flash)}&amp;java={int(java)}&amp;qt={int(quick_time)}&#34;
            f&#34;&amp;realp={int(real_player)}&amp;pdf={int(pdf)}&amp;wma={int(windows_media)}&amp;ag={int(silverlight)}&#34;
        )
        self.plugins = plugins
        return self

    def disable_cookie_support(self):
        &#34;&#34;&#34;
        By default, MatomoTracker will read first party cookies
        from the request and write updated cookies in the response (using setrawcookie).
        This can be disabled by calling this function.
        &#34;&#34;&#34;
        self.configCookiesDisabled = True

    def get_request_timeout(self):
        &#34;&#34;&#34;
        Returns the maximum number of seconds the tracker will spend waiting for a response
        from Matomo. Defaults to 600 seconds.
        &#34;&#34;&#34;
        return self.requestTimeout

    def set_request_timeout(self, timeout):
        &#34;&#34;&#34;
        Sets the maximum number of seconds that the tracker will spend waiting for a response
        from Matomo.

        * @param int timeout
        * @return self
        * @throws Exception
        &#34;&#34;&#34;
        if not is_int(timeout) or timeout &lt; 0:
            raise Exception(&#34;Invalid value supplied for request timeout: timeout&#34;)

        self.requestTimeout = timeout
        return self

    def set_request_method_non_bulk(self, method):
        &#34;&#34;&#34;
        Sets the request method to POST, which is recommended when using set_token_auth()
        to prevent the token from being recorded in server logs. Avoid using redirects
        when using POST to prevent the loss of POST values. When using Log Analytics,
        be aware that POST requests are not parseable/replayable.

        * @param str method. Either &#39;POST&#39; or &#39;get&#39;
        * @return self
        &#34;&#34;&#34;
        self.request_method = &#34;POST&#34; if method.upper() == &#34;POST&#34; else &#34;GET&#34;
        return self

    def set_proxy(self, proxy, proxy_port=80, proxy_type=&#34;https&#34;):
        &#34;&#34;&#34;
        If a proxy is needed to look up the address of the Matomo site, set it with this
        * @param str proxy IP as string, for example &#34;173.234.92.107&#34;
        * @param int proxy_port
        &#34;&#34;&#34;
        self.proxy = proxy
        self.proxy_port = proxy_port
        self.proxy_type = proxy_type

    def get_proxy(self):
        &#34;&#34;&#34;
        If the proxy IP,the proxy port and the proxy_type have been set,
        with the set_proxy() function returns a string, like &#34;https://173.234.92.107:80&#34;
        &#34;&#34;&#34;
        if self.proxy and self.proxy_port and self.proxy_type:
            return f&#34;{self.proxy_type}://{self.proxy}:{self.proxy_port}&#34;
        return None

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    def send_request(self, url, method=&#34;get&#34;, data=None, force=False):
        raise NotImplementedError(&#34;Missing send_request implementation&#34;)

    def get_timestamp(self):
        &#34;&#34;&#34;
        Returns current timestamp, or forced timestamp/datetime if it was set
        * @return str|int
        &#34;&#34;&#34;
        if self.forcedDatetime:
            return datetime.strptime(self.forcedDatetime, &#34;%Y-%m-%d %H:%M:%S&#34;).timestamp()
        else:
            return time.time()

    def get_base_url(self):
        &#34;&#34;&#34;
        Returns the base URL for the Matomo server.
        &#34;&#34;&#34;
        if not self.URL:
            raise Exception(
                (
                    &#34;You must first set the Matomo Tracker URL by calling &#34;
                    &#34;MatomoTracker.URL = &#39;http://your-website.org/matomo/&#39;&#34;
                )
            )
        if (
            strpos(self.URL, &#34;/matomo.php&#34;) is False
            and strpos(self.URL, &#34;/proxy-matomo.php&#34;) is False
        ):
            self.URL = self.URL.rstrip(&#34;/&#34;)
            self.URL += &#34;/matomo.php&#34;

        return self.URL

    &#34;&#34;&#34;
    * @ignore
    &#34;&#34;&#34;
    def get_request(self, id_site):
        self.set_first_party_cookies()

        custom_fields = &#34;&#34;
        if self.customParameters:
            custom_fields = &#34;&amp;&#34; + urlencode_plus(self.customParameters)

        custom_dimensions = &#34;&#34;
        if self.customDimensions:
            custom_dimensions = &#34;&amp;&#34; + urlencode_plus(self.customDimensions)

        base_url = self.get_base_url()
        start = &#34;?&#34;
        if strpos(base_url, &#34;?&#34;):
            start = &#34;&amp;&#34;

        url = (
            f&#34;{base_url}{start}idsite={id_site}&amp;rec=1&amp;apiv={self.VERSION}&#34;
            + f&#34;&amp;r={str(random.randint(0, 2147483647))[2:8]}&#34;
            + (f&#34;&amp;cip={self.ip}&#34; if self.ip and self.token_auth else &#34;&#34;)
            + (f&#34;&amp;uid={urlencode_plus(self.user_id)}&#34; if self.user_id else &#34;&#34;)
            + (&#34;&amp;cdt=&#34; + urlencode_plus(self.forcedDatetime) if self.forcedDatetime else &#34;&#34;)
            + (&#34;&amp;new_visit=1&#34; if self.forcedNewVisit else &#34;&#34;)
            + f&#34;&amp;_idts={self.createTs}{self.plugins}&#34;
            + (
                f&#34;&amp;h={self.local_hour}&amp;m={self.local_minute}&amp;s={self.local_second}&#34;
                if self.local_hour and self.local_minute and self.local_second
                else &#34;&#34;
            )
            + (
                f&#34;&amp;res={self.width}x{self.height}&#34;
                if self.width and self.height
                else &#34;&#34;
            )
            + (f&#34;&amp;cookie={self.hasCookies}&#34; if self.hasCookies else &#34;&#34;)
            + (f&#34;&amp;data={self.customData}&#34; if self.customData else &#34;&#34;)
            + (
                &#34;&amp;_cvar=&#34; + urlencode_plus(json.dumps(self.visitorCustomVar))
                if self.visitorCustomVar
                else &#34;&#34;
            )
            + (
                &#34;&amp;cvar=&#34; + urlencode_plus(json.dumps(self.pageCustomVar))
                if self.pageCustomVar
                else &#34;&#34;
            )
            + (
                &#34;&amp;e_cvar=&#34; + urlencode_plus(json.dumps(self.eventCustomVar))
                if self.eventCustomVar
                else &#34;&#34;
            )
            + (
                f&#34;&amp;cid={self.forcedVisitorId}&#34;
                if self.forcedVisitorId
                else f&#34;&amp;_id={self.get_visitor_id()}&#34;
            )
            + &#34;&amp;url=&#34; + urlencode_plus(self.pageUrl)
            + &#34;&amp;urlref=&#34; + urlencode_plus(self.urlReferrer)
            + (
                f&#34;&amp;cs={self.pageCharset}&#34;
                if (
                    self.pageCharset
                    and self.pageCharset != self.DEFAULT_CHARSET_PARAMETER_VALUES
                )
                else &#34;&#34;
            )
            + (f&#34;&amp;pv_id={urlencode_plus(self.idPageview)}&#34; if self.idPageview else &#34;&#34;)
            + (
                &#34;&amp;_rcn=&#34; + urlencode_plus(self.attributionInfo[0])
                if self.attributionInfo and self.attributionInfo[0]
                else &#34;&#34;
            )
            + (
                &#34;&amp;_rck=&#34; + urlencode_plus(self.attributionInfo[1])
                if self.attributionInfo and self.attributionInfo[1]
                else &#34;&#34;
            )
            + (&#34;&amp;_refts=&#34; + self.attributionInfo[2] if self.attributionInfo and self.attributionInfo[2] else &#34;&#34;)
            + (
                &#34;&amp;_ref=&#34; + urlencode_plus(self.attributionInfo[3])
                if self.attributionInfo and self.attributionInfo[3]
                else &#34;&#34;
            )
            + (f&#34;&amp;country={urlencode_plus(self.country)}&#34; if self.country else &#34;&#34;)
            + (f&#34;&amp;region={urlencode_plus(self.region)}&#34; if self.region else &#34;&#34;)
            + (f&#34;&amp;city={urlencode_plus(self.city)}&#34;  if self.city else &#34;&#34;)
            + (f&#34;&amp;lat={urlencode_plus(str(self.lat))}&#34; if self.lat else &#34;&#34;)
            + (f&#34;&amp;long={urlencode_plus(str(self.long))}&#34; if self.long else &#34;&#34;)
            + custom_fields
            + custom_dimensions
            + (&#34;&amp;send_image=0&#34; if not self.sendImageResponse else &#34;&#34;)
            + self.DEBUG_APPEND_URL
        )

        if self.idPageview:
            url += (
                (f&#34;&amp;pf_net={self.networkTime}&#34; if self.networkTime else &#34;&#34;)
                + (f&#34;&amp;pf_srv={self.serverTime}&#34; if self.serverTime else &#34;&#34;)
                + (f&#34;&amp;pf_tfr={self.transferTime}&#34; if self.transferTime else &#34;&#34;)
                + (f&#34;&amp;pf_dm1={self.domProcessingTime}&#34; if self.domProcessingTime else &#34;&#34;)
                + (f&#34;&amp;pf_dm2={self.domCompletionTime}&#34; if self.domCompletionTime else &#34;&#34;)
                + (f&#34;&amp;pf_onl={self.onLoadTime}&#34; if self.onLoadTime else &#34;&#34;)
            )
            self.clear_performance_timings()

        for key in self.ecommerceView:
            url += f&#34;&amp;{key}={urlencode_plus(self.ecommerceView[key])}&#34;

        # Reset page level custom variables after this page view
        self.ecommerceView = {}
        self.pageCustomVar = {}
        self.eventCustomVar = {}
        self.clear_custom_dimensions()
        self.clear_custom_tracking_parameters()

        # force new visit only once, user must call again set_force_new_visit()
        self.forcedNewVisit = False

        return url

    def get_cookie_matching_name(self, name):
        &#34;&#34;&#34;
        Returns a first party cookie which name contains name

        * @param str name
        * @return str String value of cookie, or None if not found
        * @ignore
        &#34;&#34;&#34;
        if self.configCookiesDisabled or not self.request.cookie.get_dict():
            return None
        name = self.get_cookie_name(name)

        # Matomo cookie names use dots separators in matomo.js,
        # but PHP Replaces + with _ http://www.php.net/manual/en/language.variables.predefined.php#72571
        name = name.replace(&#34;.&#34;, &#34;_&#34;)
        for cookie_name, cookie_value in self.request.cookie.items():
            if strpos(name, cookie_name) is not False:  # 0 is fine
                return cookie_value

        return None

    def get_current_script_name(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;/dir1/dir2/index.php&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        url = &#34;&#34;
        if self.request.get(&#34;PATH_INFO&#34;):
            url = self.request.get(&#34;PATH_INFO&#34;)
        elif self.request.get(&#34;REQUEST_URI&#34;):
            url = self.request.get(&#34;REQUEST_URI&#34;, &#34;&#34;).split(&#34;?&#34;)[0]

        if not url:
            # Use if-else instead of get with default to correctly handle empty values
            if self.request.get(&#34;SCRIPT_NAME&#34;):
                url = self.request.get(&#34;SCRIPT_NAME&#34;)
            else:
                url = &#34;/&#34;

        if url and url[0] != &#34;/&#34;:
            url = &#34;/&#34; + url

        return url

    def get_current_scheme(self):
        &#34;&#34;&#34;
        If the current URL is &#39;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#39;http&#39;

        * @return str &#39;https&#39; or &#39;http&#39;
        * @ignore
        &#34;&#34;&#34;
        if &#34;HTTPS&#34; in self.request and (
            self.request.get(&#34;HTTPS&#34;) == &#34;on&#34; or self.request.get(&#34;HTTPS&#34;) is True
        ):
            return &#34;https&#34;
        return &#34;http&#34;

    def get_current_host(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;http://example.org&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        return self.request.get(&#34;HTTP_HOST&#34;, &#34;unknown&#34;)

    def get_current_query_string(self):
        &#34;&#34;&#34;
        If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
        will return &#34;?param1=value1&amp;param2=value2&#34;

        * @return str
        * @ignore
        &#34;&#34;&#34;
        url = &#34;&#34;
        if self.request.get(&#34;QUERY_STRING&#34;):
            url += &#34;?&#34; + self.request.get(&#34;QUERY_STRING&#34;)
        return url

    def get_current_url(self):
        &#34;&#34;&#34;
        Returns the current full URL (scheme, host, path and query string.

        * @return str
        * @ignore
        &#34;&#34;&#34;
        return &#34;&#34;.join(
            [
                self.get_current_scheme(),
                &#34;://&#34;,
                self.get_current_host(),
                self.get_current_script_name(),
                self.get_current_query_string(),
            ]
        )

    def set_first_party_cookies(self):
        &#34;&#34;&#34;
        Sets the first party cookies as would the matomo.js
        All cookies are supported: &#39;id&#39; and &#39;ses&#39; and &#39;ref&#39; and &#39;cvar&#39; cookies.
        * @return self
        &#34;&#34;&#34;
        if self.configCookiesDisabled:
            return self

        if self.cookieVisitorId:
            self.load_visitor_id_cookie()

        # Set the &#39;ref&#39; cookie
        attribution_info = self.get_attribution_info()
        if attribution_info:
            self.set_cookie(&#34;ref&#34;, attribution_info, self.configReferralCookieTimeout)

        # Set the &#39;ses&#39; cookie
        self.set_cookie(&#34;ses&#34;, &#34;*&#34;, self.configSessionCookieTimeout)

        # Set the &#39;id&#39; cookie
        cookie_value = f&#34;{self.get_visitor_id()}.{self.createTs}&#34;
        self.set_cookie(&#34;id&#34;, cookie_value, self.configVisitorCookieTimeout)

        # Set the &#39;cvar&#39; cookie
        self.set_cookie(
            &#34;cvar&#34;, json.dumps(self.visitorCustomVar), self.configSessionCookieTimeout
        )
        return self

    def _set_cookie(self, cookie_name, cookie_value, cookie_ttl):
        &#34;&#34;&#34;
        Sets a first party cookie to the client to improve dual JS-Python tracking.

        This replicates the matomo.js tracker algorithms for consistency and better accuracy.

        * @param cookie_name
        * @param cookie_value
        * @param cookie_ttl
        * @return self
        &#34;&#34;&#34;
        cookie_expire = self.currentTs + cookie_ttl
        cookie_header = (
            f&#34;Set-Cookie: {urlencode_plus(cookie_name)}={urlencode_plus(cookie_value)}&#34;
            (f&#34;; expires=&#39;{time.strftime(&#39;%a, %d-%m-%Y %H:%M:%S&#39;, cookieExpire)} GMT&#34; if cookie_expire else &#34;&#34;)
            (f&#34;; path=&#39;{self.configCookiePath}&#34; if self.configCookiePath else &#34;&#34;)
            (f&#34;; domain=&#39;{self.configCookieDomain}&#34; if self.configCookieDomain else &#34;&#34;)
            (f&#34;; secure&#34; if self.configCookieSecure else &#34;&#34;)
            (f&#34;; HttpOnly&#34; if self.configCookieHTTPOnly else &#34;&#34;)
            (f&#34;; SameSite={urlencode_plus(self.configCookieSameSite)}&#34; if self.configCookieSameSite else &#34;&#34;)
        )
        return cookie_header

    def set_cookie(self, cookie_name, cookie_value, cookie_ttl):
        &#34;&#34;&#34;
        Sets a first party cookie to the client to improve dual JS-Python tracking.

        This replicates the matomo.js tracker algorithms for consistency and better accuracy.

        * @param cookie_name
        * @param cookie_value
        * @param cookie_ttl
        * @return self
        &#34;&#34;&#34;
        cookie_expire = self.currentTs + cookie_ttl
        self.request.cookie.set(cookie_name, cookie_value, expires=cookie_expire)
        return self

    def get_cookies(self):
        return self.request.cookie

    def get_custom_variables_from_cookie(self):
        &#34;&#34;&#34;
        * @return bool|mixed
        &#34;&#34;&#34;
        cookie = self.get_cookie_matching_name(&#34;cvar&#34;)
        if not cookie:
            return False

        return json.loads(cookie)

    def set_outgoing_tracker_cookie(self, name, value=None):
        &#34;&#34;&#34;
        Sets a cookie to be sent to the tracking server.

        * @param name
        * @param value
        &#34;&#34;&#34;
        if value is None:
            del self.outgoingTrackerCookies[name]
        else:
            self.outgoingTrackerCookies[name] = value

    def get_incoming_tracker_cookie(self, name):
        &#34;&#34;&#34;
        Gets a cookie which was set by the tracking server.

        * @param name

        * @return bool|string
        &#34;&#34;&#34;
        return self.incomingTrackerCookies.get(name, False)

    def parse_incoming_cookies(self, headers):
        &#34;&#34;&#34;
        Reads incoming tracking server cookies.

        * @param array headers Array with HTTP response headers as values
        &#34;&#34;&#34;
        self.incomingTrackerCookies = {}

        if headers:
            header_name = &#34;set-cookie:&#34;
            header_name_length = len(header_name)

            for header in headers:
                if strpos(header.lower(), header_name) != 0:
                    continue
                cookies = header[header_name_length:].strip()
                pos_end = strpos(cookies, &#34;;&#34;)
                if pos_end is not False:  # 0 != False
                    cookies = cookies[:pos_end]
                self.incomingTrackerCookies = parse_qs(cookies)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.matomo.Matomo" href="index.html#src.matomo.Matomo">Matomo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="src.matomo.tracker.MatomoTracker.DEBUG_APPEND_URL"><code class="name">var <span class="ident">DEBUG_APPEND_URL</span></code></dt>
<dd>
<div class="desc"><p>Visitor ID length</p>
<ul>
<li>@ignore</li>
</ul></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.DEFAULT_CHARSET_PARAMETER_VALUES"><code class="name">var <span class="ident">DEFAULT_CHARSET_PARAMETER_VALUES</span></code></dt>
<dd>
<div class="desc"><p>See matomo.js</p></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.DEFAULT_COOKIE_PATH"><code class="name">var <span class="ident">DEFAULT_COOKIE_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.FIRST_PARTY_COOKIES_PREFIX"><code class="name">var <span class="ident">FIRST_PARTY_COOKIES_PREFIX</span></code></dt>
<dd>
<div class="desc"><p>Defines how many categories can be used max when calling add_ecommerce_item().
* @var int</p></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.LENGTH_VISITOR_ID"><code class="name">var <span class="ident">LENGTH_VISITOR_ID</span></code></dt>
<dd>
<div class="desc"><p>Charset
* @see set_page_charset
* @ignore</p></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.MAX_NUM_ECOMMERCE_ITEM_CATEGORIES"><code class="name">var <span class="ident">MAX_NUM_ECOMMERCE_ITEM_CATEGORIES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.URL"><code class="name">var <span class="ident">URL</span></code></dt>
<dd>
<div class="desc"><p>API Version</p>
<ul>
<li>@ignore</li>
<li>@var int</li>
</ul></div>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"><ul>
<li>@ignore</li>
</ul></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.matomo.tracker.MatomoTracker.add_ecommerce_item"><code class="name flex">
<span>def <span class="ident">add_ecommerce_item</span></span>(<span>self, sku, name='', category='', price=0.0, quantity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an item in the Ecommerce order.</p>
<p>This should be called before do_track_ecommerce_order(), or before do_track_ecommerce_cart_update().
This function can be called for all individual products in the cart (self, or order):.
SKU parameter is mandatory. Other parameters are optional (set to False if value not known).
Ecommerce items added via this function are automatically cleared when
do_track_ecommerce_order() or get_url_track_ecommerce_order() is called.</p>
<ul>
<li>@param str sku (required) SKU, Product identifier</li>
<li>@param str name (optional) Product name</li>
<li>@param str|list category (optional) Product category, or list of product categories (up to 5 categories can be specified for a given product)</li>
<li>@param float|int price (optional) Individual product price (supports integer and decimal prices)</li>
<li>@param int quantity (optional) Product quantity. If specified, will default to 1 not in the Reports</li>
<li>@throws Exception</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ecommerce_item(self, sku, name=&#34;&#34;, category=&#34;&#34;, price=0.0, quantity=1):
    &#34;&#34;&#34;
    Adds an item in the Ecommerce order.

    This should be called before do_track_ecommerce_order(), or before do_track_ecommerce_cart_update().
    This function can be called for all individual products in the cart (self, or order):.
    SKU parameter is mandatory. Other parameters are optional (set to False if value not known).
    Ecommerce items added via this function are automatically cleared when
    do_track_ecommerce_order() or get_url_track_ecommerce_order() is called.

    * @param str sku (required) SKU, Product identifier
    * @param str name (optional) Product name
    * @param str|list category (optional) Product category, or list of product categories (up to 5 categories can be specified for a given product)
    * @param float|int price (optional) Individual product price (supports integer and decimal prices)
    * @param int quantity (optional) Product quantity. If specified, will default to 1 not in the Reports
    * @throws Exception
    * @return self
    &#34;&#34;&#34;
    if not sku:
        raise Exception(&#34;You must specify a SKU for the Ecommerce item&#34;)

    price = self.force_dot_as_separator_for_decimal_point(price)
    self.ecommerceItems = [sku, name, category, price, quantity]
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.clear_custom_dimensions"><code class="name flex">
<span>def <span class="ident">clear_custom_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all previously set custom dimensions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_custom_dimensions(self):
    &#34;&#34;&#34;
    Clears all previously set custom dimensions
    &#34;&#34;&#34;
    self.customDimensions = {}</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.clear_custom_tracking_parameters"><code class="name flex">
<span>def <span class="ident">clear_custom_tracking_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear / reset all previously set custom tracking parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_custom_tracking_parameters(self):
    &#34;&#34;&#34;
    Clear / reset all previously set custom tracking parameters.
    &#34;&#34;&#34;
    self.customParameters = {}</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.clear_custom_variables"><code class="name flex">
<span>def <span class="ident">clear_custom_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears any Custom Variable that may be have been set.</p>
<p>This can be useful when you have enabled bulk requests,
and you wish to clear Custom Variables of 'visit' scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_custom_variables(self):
    &#34;&#34;&#34;
    Clears any Custom Variable that may be have been set.

    This can be useful when you have enabled bulk requests,
    and you wish to clear Custom Variables of &#39;visit&#39; scope.
    &#34;&#34;&#34;
    self.visitorCustomVar = {}
    self.pageCustomVar = {}
    self.eventCustomVar = {}</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.clear_performance_timings"><code class="name flex">
<span>def <span class="ident">clear_performance_timings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear / reset all previously set performance metrics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_performance_timings(self):
    &#34;&#34;&#34;
    Clear / reset all previously set performance metrics.
    &#34;&#34;&#34;
    self.networkTime = 0
    self.serverTime = 0
    self.transferTime = 0
    self.domProcessingTime = 0
    self.domCompletionTime = 0
    self.onLoadTime = 0</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.delete_cookies"><code class="name flex">
<span>def <span class="ident">delete_cookies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes all first party cookies from the client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_cookies(self):
    &#34;&#34;&#34;
    Deletes all first party cookies from the client
    &#34;&#34;&#34;
    cookies = [&#34;id&#34;, &#34;ses&#34;, &#34;cvar&#34;, &#34;ref&#34;]
    for cookie in cookies:
        self.set_cookie(cookie, None, -86400)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.disable_cookie_support"><code class="name flex">
<span>def <span class="ident">disable_cookie_support</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>By default, MatomoTracker will read first party cookies
from the request and write updated cookies in the response (using setrawcookie).
This can be disabled by calling this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_cookie_support(self):
    &#34;&#34;&#34;
    By default, MatomoTracker will read first party cookies
    from the request and write updated cookies in the response (using setrawcookie).
    This can be disabled by calling this function.
    &#34;&#34;&#34;
    self.configCookiesDisabled = True</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.disable_send_image_response"><code class="name flex">
<span>def <span class="ident">disable_send_image_response</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If image response is disabled Matomo will respond with a HTTP 204 header instead of responding with a gif.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_send_image_response(self):
    &#34;&#34;&#34;
    If image response is disabled Matomo will respond with a HTTP 204 header instead of responding with a gif.
    &#34;&#34;&#34;
    self.sendImageResponse = False</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_bulk_track"><code class="name flex">
<span>def <span class="ident">do_bulk_track</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends all stored tracking actions at once. Only has an effect if bulk tracking is enabled.</p>
<p>To enable bulk tracking, call enable_bulk_tracking().</p>
<ul>
<li>@throws Exception</li>
<li>@return str Response</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_bulk_track(self):
    &#34;&#34;&#34;
    Sends all stored tracking actions at once. Only has an effect if bulk tracking is enabled.

    To enable bulk tracking, call enable_bulk_tracking().

    * @throws Exception
    * @return str Response
    &#34;&#34;&#34;
    if not self.storedTrackingActions:
        raise Exception(
            (
                &#34;Error: you must call the function do_track_page_view or do_track_goal&#34;
                &#34; from this class, before calling this method do_bulk_track():&#34;
            )
        )

    data = {&#34;requests&#34;: self.storedTrackingActions}

    # token_auth is not required by default, except if bulk_requests_require_authentication=1
    if self.token_auth:
        data[&#34;token_auth&#34;] = self.token_auth

    post_data = json.dumps(data)
    response = self.send_request(self.get_base_url(), &#34;POST&#34;, post_data, force=True)

    self.storedTrackingActions = []

    return response</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_ping"><code class="name flex">
<span>def <span class="ident">do_ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a ping request.</p>
<p>Ping requests do track new actions. If they are sent within the standard visit length (see global.ini.php), * they will extend the existing visit and the current last action for the visit. If after the standard visit length, * ping requests will create a new visit using the last action not in the last known visit.</p>
<ul>
<li>@return mixed Response or True if using bulk request</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_ping(self):
    &#34;&#34;&#34;
    Sends a ping request.

    Ping requests do track new actions. If they are sent within the standard visit length (see global.ini.php), * they will extend the existing visit and the current last action for the visit. If after the standard visit length, * ping requests will create a new visit using the last action not in the last known visit.

    * @return mixed Response or True if using bulk request
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)
    url += &#34;&amp;ping=1&#34;

    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_action"><code class="name flex">
<span>def <span class="ident">do_track_action</span></span>(<span>self, action_url, action_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks a download or outlink</p>
<ul>
<li>@param str action_url URL of the download or outlink</li>
<li>@param str action_type Type of the action: 'download' or 'link'</li>
<li>@return mixed Response string or True if using bulk request</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_action(self, action_url, action_type):
    &#34;&#34;&#34;
    Tracks a download or outlink

    * @param str action_url URL of the download or outlink
    * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
    * @return mixed Response string or True if using bulk request
    &#34;&#34;&#34;
    # Referrer could be updated to be the current URL temporarily (to mimic JS behavior)
    url = self.get_url_track_action(action_url, action_type)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_content_impression"><code class="name flex">
<span>def <span class="ident">do_track_content_impression</span></span>(<span>self, content_name, content_piece='Unknown', content_target='')</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks a content impression</p>
<ul>
<li>@param str content_name The name of the content. For instance 'Ad Foo Bar'</li>
<li>@param str content_piece The actual content. For instance the path to an image, video, audio, any text</li>
<li>@param str content_target (optional) The target of the content. For instance the URL of a landing page.</li>
<li>@return mixed Response string or True if using bulk requests.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_content_impression(
    self, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
):
    &#34;&#34;&#34;
    Tracks a content impression

    * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
    * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
    * @param str content_target (optional) The target of the content. For instance the URL of a landing page.
    * @return mixed Response string or True if using bulk requests.
    &#34;&#34;&#34;
    url = self.get_url_track_content_impression(
        content_name, content_piece, content_target
    )
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_content_interaction"><code class="name flex">
<span>def <span class="ident">do_track_content_interaction</span></span>(<span>self, interaction, content_name, content_piece='Unknown', content_target='')</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks a content interaction. Make sure you have tracked a content impression using the same content name and
content piece, otherwise it will not count. To do so you should call the method do_track_content_impression()</p>
<ul>
<li>@param str interaction The name of the interaction with the content. For instance a 'click'</li>
<li>@param str content_name The name of the content. For instance 'Ad Foo Bar'</li>
<li>@param str content_piece The actual content. For instance the path to an image, video, audio, any text</li>
<li>@param str content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.</li>
<li>@return mixed Response string or True if using bulk requests.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_content_interaction(
    self, interaction, content_name, content_piece=&#34;Unknown&#34;, content_target=&#34;&#34;
):
    &#34;&#34;&#34;
    Tracks a content interaction. Make sure you have tracked a content impression using the same content name and
    content piece, otherwise it will not count. To do so you should call the method do_track_content_impression()

    * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
    * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
    * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
    * @param str content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
    * @return mixed Response string or True if using bulk requests.
    &#34;&#34;&#34;
    url = self.get_url_track_content_interaction(
        interaction, content_name, content_piece, content_target
    )

    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_ecommerce_cart_update"><code class="name flex">
<span>def <span class="ident">do_track_ecommerce_cart_update</span></span>(<span>self, grand_total)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks a Cart Update (add item, remove item, update item).</p>
<p>On every Cart update, you must call add_ecommerce_item() for each item
(product) in the cart, including the items that haven't been updated
since the last cart update.
Items which were in the previous cart and are sent not in later Cart
updates will be deleted from the cart (in the database).</p>
<ul>
<li>@param float grand_total Cart grand_total (typically the sum of all items' prices)</li>
<li>@return mixed Response string or True if using bulk request</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_ecommerce_cart_update(self, grand_total):
    &#34;&#34;&#34;
    Tracks a Cart Update (add item, remove item, update item).

    On every Cart update, you must call add_ecommerce_item() for each item
    (product) in the cart, including the items that haven&#39;t been updated
    since the last cart update.
    Items which were in the previous cart and are sent not in later Cart
    updates will be deleted from the cart (in the database).

    * @param float grand_total Cart grand_total (typically the sum of all items&#39; prices)
    * @return mixed Response string or True if using bulk request
    &#34;&#34;&#34;
    url = self.get_url_track_ecommerce_cart_update(grand_total)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_ecommerce_order"><code class="name flex">
<span>def <span class="ident">do_track_ecommerce_order</span></span>(<span>self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks an Ecommerce order.</p>
<p>If the Ecommerce order contains items (products), you must call first the add_ecommerce_item() for each item in the order.
All revenues (grand_total, sub_total, tax, shipping, discount) will be individually summed and reported in Matomo reports.
Only the parameters order_id and grand_total are required.</p>
<ul>
<li>@param str|int order_id (required) Unique Order ID.
This will be used to count this order only once in the event the order page is reloaded several times.
order_id must be unique for each transaction, even on different days, or the transaction will not be recorded by Matomo.</li>
<li>@param float grand_total (required) Grand Total revenue of the transaction (including tax, shipping, etc.)</li>
<li>@param float sub_total (optional) Sub total amount, typically the sum of items prices for all items in this order (before Tax and Shipping costs are applied)</li>
<li>@param float tax (optional) Tax amount for this order</li>
<li>@param float shipping (optional) Shipping amount for this order</li>
<li>@param float discount (optional) Discounted amount in this order</li>
<li>@return mixed Response or True if using bulk request</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_ecommerce_order(
    self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
):
    &#34;&#34;&#34;
    Tracks an Ecommerce order.

    If the Ecommerce order contains items (products), you must call first the add_ecommerce_item() for each item in the order.
    All revenues (grand_total, sub_total, tax, shipping, discount) will be individually summed and reported in Matomo reports.
    Only the parameters order_id and grand_total are required.

    * @param str|int order_id (required) Unique Order ID.
                   This will be used to count this order only once in the event the order page is reloaded several times.
                   order_id must be unique for each transaction, even on different days, or the transaction will not be recorded by Matomo.
    * @param float grand_total (required) Grand Total revenue of the transaction (including tax, shipping, etc.)
    * @param float sub_total (optional) Sub total amount, typically the sum of items prices for all items in this order (before Tax and Shipping costs are applied)
    * @param float tax (optional) Tax amount for this order
    * @param float shipping (optional) Shipping amount for this order
    * @param float discount (optional) Discounted amount in this order
    * @return mixed Response or True if using bulk request
    &#34;&#34;&#34;
    url = self.get_url_track_ecommerce_order(
        order_id, grand_total, sub_total, tax, shipping, discount
    )
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_event"><code class="name flex">
<span>def <span class="ident">do_track_event</span></span>(<span>self, category, action, name='', value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks an event</p>
<ul>
<li>@param str category The Event Category (Videos, Music, Games&hellip;)</li>
<li>@param str action The Event's Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked&hellip;)</li>
<li>@param str name (optional) The Event's object Name (a particular Movie name, or Song name, or File name&hellip;)</li>
<li>@param float value (optional) The Event's value</li>
<li>@return mixed Response string or True if using bulk requests.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_event(self, category, action, name=&#34;&#34;, value=0):
    &#34;&#34;&#34;
    Tracks an event

    * @param str category The Event Category (Videos, Music, Games...)
    * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
    * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
    * @param float value (optional) The Event&#39;s value
    * @return mixed Response string or True if using bulk requests.
    &#34;&#34;&#34;
    url = self.get_url_track_event(category, action, name, value)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_goal"><code class="name flex">
<span>def <span class="ident">do_track_goal</span></span>(<span>self, id_goal, revenue=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Records a Goal conversion</p>
<ul>
<li>@param int id_goal Id Goal to record a conversion</li>
<li>@param float revenue Revenue for this conversion</li>
<li>@return mixed Response string or True if using bulk request</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_goal(self, id_goal, revenue=0.0):
    &#34;&#34;&#34;
    Records a Goal conversion

    * @param int id_goal Id Goal to record a conversion
    * @param float revenue Revenue for this conversion
    * @return mixed Response string or True if using bulk request
    &#34;&#34;&#34;
    url = self.get_url_track_goal(id_goal, revenue)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_page_view"><code class="name flex">
<span>def <span class="ident">do_track_page_view</span></span>(<span>self, document_title)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks a page view</p>
<ul>
<li>@param str document_title Page title as it will appear in the Actions &gt; Page titles report</li>
<li>@return mixed Response string or True if using bulk requests.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_page_view(self, document_title):
    &#34;&#34;&#34;
    Tracks a page view

    * @param str document_title Page title as it will appear in the Actions &gt; Page titles report
    * @return mixed Response string or True if using bulk requests.
    &#34;&#34;&#34;
    self.generate_new_pageview_id()
    url = self.get_url_track_page_view(document_title)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.do_track_site_search"><code class="name flex">
<span>def <span class="ident">do_track_site_search</span></span>(<span>self, keyword, category='', count_results=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracks an internal Site Search query, and optionally tracks the Search
Category, and Search results Count.
These are used to populate reports in Actions &gt; Site Search.</p>
<ul>
<li>@param str keyword Searched query on the site</li>
<li>@param str category (optional) Search engine category if applicable</li>
<li>
<p>@param int count_results (optional) results displayed on the search
result page. Used to track "zero result" keywords.</p>
</li>
<li>
<p>@return mixed Response string or True if using bulk requests.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_track_site_search(self, keyword, category=&#34;&#34;, count_results=0):
    &#34;&#34;&#34;
    Tracks an internal Site Search query, and optionally tracks the Search
    Category, and Search results Count.
    These are used to populate reports in Actions &gt; Site Search.

    * @param str keyword Searched query on the site
    * @param str category (optional) Search engine category if applicable
    * @param int count_results (optional) results displayed on the search
    result page. Used to track &#34;zero result&#34; keywords.

    * @return mixed Response string or True if using bulk requests.
    &#34;&#34;&#34;
    url = self.get_url_track_site_search(keyword, category, count_results)
    return self.send_request(url)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.domain_fixup"><code class="name flex">
<span>def <span class="ident">domain_fixup</span></span>(<span>self, domain)</span>
</code></dt>
<dd>
<div class="desc"><p>Fix-up domain</p>
<p>Remove trailing '.' and leading '*.'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def domain_fixup(self, domain):
    &#34;&#34;&#34;
    Fix-up domain

    Remove trailing &#39;.&#39; and leading &#39;*.&#39;
    &#34;&#34;&#34;
    return domain.rstrip(&#34;.&#34;).lstrip(&#34;*.&#34;)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.enable_bulk_tracking"><code class="name flex">
<span>def <span class="ident">enable_bulk_tracking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the bulk request feature. When used, each tracking action is stored until the
do_bulk_track method is called. This method will send all tracking data at once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_bulk_tracking(self):
    &#34;&#34;&#34;
    Enables the bulk request feature. When used, each tracking action is stored until the
    do_bulk_track method is called. This method will send all tracking data at once.

    &#34;&#34;&#34;
    self.doBulkRequests = True</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.enable_cookies"><code class="name flex">
<span>def <span class="ident">enable_cookies</span></span>(<span>self, domain='', path='/', secure=False, http_only=False, same_site='')</span>
</code></dt>
<dd>
<div class="desc"><p>Enable cookie creation - this will cause a first party VisitorId cookie to be set when the VisitorId is set or reset</p>
<ul>
<li>@param str domain (optional) Set first-party cookie domain.
Accepted values: example.com, *.example.com (same as .example.com) or subdomain.example.com</li>
<li>@param str path (optional) Set first-party cookie path</li>
<li>@param bool secure (optional) Set secure flag for cookies</li>
<li>@param bool http_only (optional) Set HTTPOnly flag for cookies</li>
<li>@param str same_site (optional) Set SameSite flag for cookies</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_cookies(
    self, domain=&#34;&#34;, path=&#34;/&#34;, secure=False, http_only=False, same_site=&#34;&#34;
):
    &#34;&#34;&#34;
    Enable cookie creation - this will cause a first party VisitorId cookie to be set when the VisitorId is set or reset

    * @param str domain (optional) Set first-party cookie domain.
                Accepted values: example.com, *.example.com (same as .example.com) or subdomain.example.com
    * @param str path (optional) Set first-party cookie path
    * @param bool secure (optional) Set secure flag for cookies
    * @param bool http_only (optional) Set HTTPOnly flag for cookies
    * @param str same_site (optional) Set SameSite flag for cookies
    &#34;&#34;&#34;
    self.configCookiesDisabled = False
    self.configCookieDomain = self.domain_fixup(domain)
    self.configCookiePath = path
    self.configCookieSecure = secure
    self.configCookieHTTPOnly = http_only
    self.configCookieSameSite = same_site</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.force_dot_as_separator_for_decimal_point"><code class="name flex">
<span>def <span class="ident">force_dot_as_separator_for_decimal_point</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Force the separator for decimal point to be a dot. See <a href="https://github.com/matomo-org/matomo/issues/6435">https://github.com/matomo-org/matomo/issues/6435</a>
If for instance a German locale is used it would be a comma otherwise.</p>
<ul>
<li>@param
float|string value</li>
<li>@return str</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_dot_as_separator_for_decimal_point(self, value):
    &#34;&#34;&#34;
    Force the separator for decimal point to be a dot. See https://github.com/matomo-org/matomo/issues/6435
    If for instance a German locale is used it would be a comma otherwise.

    * @param  float|string value
    * @return str
    &#34;&#34;&#34;
    if value is None or value is False:
        return &#34;&#34;
    return str(value).replace(&#34;,&#34;, &#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.generate_new_pageview_id"><code class="name flex">
<span>def <span class="ident">generate_new_pageview_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_new_pageview_id(self):
    self.idPageview = uuid.uuid4().hex[:6]</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_attribution_info"><code class="name flex">
<span>def <span class="ident">get_attribution_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the currently assigned Attribution Information stored in a first party cookie.</p>
<p>This function will only work if the user is initiating the current request, and his cookies
can be read by Python from the self.request.cookie object.</p>
<ul>
<li>@return str JSON Encoded string containing the Referrer information for Goal conversion attribution.
Will return False if the cookie could not be found</li>
<li>@see matomo.js get_attribution_info()</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attribution_info(self):
    &#34;&#34;&#34;
    Returns the currently assigned Attribution Information stored in a first party cookie.

    This function will only work if the user is initiating the current request, and his cookies
    can be read by Python from the self.request.cookie object.

    * @return str JSON Encoded string containing the Referrer information for Goal conversion attribution.
                   Will return False if the cookie could not be found
    * @see matomo.js get_attribution_info()
    &#34;&#34;&#34;
    if self.attributionInfo:
        return json.dumps(self.attributionInfo)

    return self.get_cookie_matching_name(&#34;ref&#34;)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_base_url"><code class="name flex">
<span>def <span class="ident">get_base_url</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the base URL for the Matomo server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base_url(self):
    &#34;&#34;&#34;
    Returns the base URL for the Matomo server.
    &#34;&#34;&#34;
    if not self.URL:
        raise Exception(
            (
                &#34;You must first set the Matomo Tracker URL by calling &#34;
                &#34;MatomoTracker.URL = &#39;http://your-website.org/matomo/&#39;&#34;
            )
        )
    if (
        strpos(self.URL, &#34;/matomo.php&#34;) is False
        and strpos(self.URL, &#34;/proxy-matomo.php&#34;) is False
    ):
        self.URL = self.URL.rstrip(&#34;/&#34;)
        self.URL += &#34;/matomo.php&#34;

    return self.URL</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_cookie_matching_name"><code class="name flex">
<span>def <span class="ident">get_cookie_matching_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a first party cookie which name contains name</p>
<ul>
<li>@param str name</li>
<li>@return str String value of cookie, or None if not found</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cookie_matching_name(self, name):
    &#34;&#34;&#34;
    Returns a first party cookie which name contains name

    * @param str name
    * @return str String value of cookie, or None if not found
    * @ignore
    &#34;&#34;&#34;
    if self.configCookiesDisabled or not self.request.cookie.get_dict():
        return None
    name = self.get_cookie_name(name)

    # Matomo cookie names use dots separators in matomo.js,
    # but PHP Replaces + with _ http://www.php.net/manual/en/language.variables.predefined.php#72571
    name = name.replace(&#34;.&#34;, &#34;_&#34;)
    for cookie_name, cookie_value in self.request.cookie.items():
        if strpos(name, cookie_name) is not False:  # 0 is fine
            return cookie_value

    return None</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_cookie_name"><code class="name flex">
<span>def <span class="ident">get_cookie_name</span></span>(<span>self, cookie_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cookie name with prefix and domain hash
* @param str cookie_name
* @return str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cookie_name(self, cookie_name):
    &#34;&#34;&#34;
    Get cookie name with prefix and domain hash
    * @param str cookie_name
    * @return str
    &#34;&#34;&#34;
    hash_string = hashlib.sha1(
        (
            self.get_current_host()
            if self.configCookieDomain == &#34;&#34;
            else self.configCookieDomain
        ).encode(&#34;utf-8&#34;)
        + self.configCookiePath.encode(&#34;utf-8&#34;)
    ).hexdigest()[:4]

    return &#34;{}{}.{}.{}&#34;.format(
        self.FIRST_PARTY_COOKIES_PREFIX,
        cookie_name,
        self.id_site,
        hash_string
    )</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_cookies"><code class="name flex">
<span>def <span class="ident">get_cookies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cookies(self):
    return self.request.cookie</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_current_host"><code class="name flex">
<span>def <span class="ident">get_current_host</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If current URL is "http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2"
will return "http://example.org"</p>
<ul>
<li>@return str</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_host(self):
    &#34;&#34;&#34;
    If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
    will return &#34;http://example.org&#34;

    * @return str
    * @ignore
    &#34;&#34;&#34;
    return self.request.get(&#34;HTTP_HOST&#34;, &#34;unknown&#34;)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_current_query_string"><code class="name flex">
<span>def <span class="ident">get_current_query_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If current URL is "http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2"
will return "?param1=value1&amp;param2=value2"</p>
<ul>
<li>@return str</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_query_string(self):
    &#34;&#34;&#34;
    If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
    will return &#34;?param1=value1&amp;param2=value2&#34;

    * @return str
    * @ignore
    &#34;&#34;&#34;
    url = &#34;&#34;
    if self.request.get(&#34;QUERY_STRING&#34;):
        url += &#34;?&#34; + self.request.get(&#34;QUERY_STRING&#34;)
    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_current_scheme"><code class="name flex">
<span>def <span class="ident">get_current_scheme</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the current URL is 'http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2"
will return 'http'</p>
<ul>
<li>@return str 'https' or 'http'</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_scheme(self):
    &#34;&#34;&#34;
    If the current URL is &#39;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
    will return &#39;http&#39;

    * @return str &#39;https&#39; or &#39;http&#39;
    * @ignore
    &#34;&#34;&#34;
    if &#34;HTTPS&#34; in self.request and (
        self.request.get(&#34;HTTPS&#34;) == &#34;on&#34; or self.request.get(&#34;HTTPS&#34;) is True
    ):
        return &#34;https&#34;
    return &#34;http&#34;</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_current_script_name"><code class="name flex">
<span>def <span class="ident">get_current_script_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If current URL is "http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2"
will return "/dir1/dir2/index.php"</p>
<ul>
<li>@return str</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_script_name(self):
    &#34;&#34;&#34;
    If current URL is &#34;http://example.org/dir1/dir2/index.php?param1=value1&amp;param2=value2&#34;
    will return &#34;/dir1/dir2/index.php&#34;

    * @return str
    * @ignore
    &#34;&#34;&#34;
    url = &#34;&#34;
    if self.request.get(&#34;PATH_INFO&#34;):
        url = self.request.get(&#34;PATH_INFO&#34;)
    elif self.request.get(&#34;REQUEST_URI&#34;):
        url = self.request.get(&#34;REQUEST_URI&#34;, &#34;&#34;).split(&#34;?&#34;)[0]

    if not url:
        # Use if-else instead of get with default to correctly handle empty values
        if self.request.get(&#34;SCRIPT_NAME&#34;):
            url = self.request.get(&#34;SCRIPT_NAME&#34;)
        else:
            url = &#34;/&#34;

    if url and url[0] != &#34;/&#34;:
        url = &#34;/&#34; + url

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_current_url"><code class="name flex">
<span>def <span class="ident">get_current_url</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current full URL (scheme, host, path and query string.</p>
<ul>
<li>@return str</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_url(self):
    &#34;&#34;&#34;
    Returns the current full URL (scheme, host, path and query string.

    * @return str
    * @ignore
    &#34;&#34;&#34;
    return &#34;&#34;.join(
        [
            self.get_current_scheme(),
            &#34;://&#34;,
            self.get_current_host(),
            self.get_current_script_name(),
            self.get_current_query_string(),
        ]
    )</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_custom_dimension"><code class="name flex">
<span>def <span class="ident">get_custom_dimension</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the custom dimension with the given id</p>
<ul>
<li>@param int id id of custom dimension</li>
<li>@return str | None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_dimension(self, id):
    &#34;&#34;&#34;
    Returns the value of the custom dimension with the given id

    * @param int id id of custom dimension
    * @return str | None
    &#34;&#34;&#34;
    return self.customDimensions.get(f&#34;dimension{id}&#34;, None)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_custom_variable"><code class="name flex">
<span>def <span class="ident">get_custom_variable</span></span>(<span>self, id, scope='visit')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the currently assigned Custom Variable.</p>
<p>If scope is 'visit', it will attempt to read the value set in the first party cookie created by Matomo Tracker
(self.request.cookie array).</p>
<ul>
<li>@param int id Custom Variable integer index to fetch from cookie. Should be a value from 1 to 5</li>
<li>
<p>@param str scope Custom variable scope. Possible values: visit, page, event</p>
</li>
<li>
<p>@throws Exception</p>
</li>
<li>@return list A list with this format: [ CustomVariableName, CustomVariableValue ] or False</li>
<li>@see matomo.js getCustomVariable()</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_variable(self, id, scope=&#34;visit&#34;):
    &#34;&#34;&#34;
    Returns the currently assigned Custom Variable.

    If scope is &#39;visit&#39;, it will attempt to read the value set in the first party cookie created by Matomo Tracker
     (self.request.cookie array).

    * @param int id Custom Variable integer index to fetch from cookie. Should be a value from 1 to 5
    * @param str scope Custom variable scope. Possible values: visit, page, event

    * @throws Exception
    * @return list A list with this format: [ CustomVariableName, CustomVariableValue ] or False
    * @see matomo.js getCustomVariable()
    &#34;&#34;&#34;
    if scope == &#34;page&#34;:
        return self.pageCustomVar.get(id, False)
    elif scope == &#34;event&#34;:
        return self.eventCustomVar.get(id, False)
    else:
        if scope != &#34;visit&#34;:
            raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
    if self.visitorCustomVar.get(id):
        return self.visitorCustomVar[id]

    cookie_decoded = self.get_custom_variables_from_cookie()
    if not is_int(id):
        raise Exception(&#34;Parameter to get_custom_variable should be an integer&#34;)
    if (
        not is_dict(cookie_decoded)
        or id not in cookie_decoded
        or not is_list(cookie_decoded[id])
        or len(cookie_decoded[id]) != 2
    ):
        return False

    return cookie_decoded[id]</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_custom_variables_from_cookie"><code class="name flex">
<span>def <span class="ident">get_custom_variables_from_cookie</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>@return bool|mixed</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_custom_variables_from_cookie(self):
    &#34;&#34;&#34;
    * @return bool|mixed
    &#34;&#34;&#34;
    cookie = self.get_cookie_matching_name(&#34;cvar&#34;)
    if not cookie:
        return False

    return json.loads(cookie)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_incoming_tracker_cookie"><code class="name flex">
<span>def <span class="ident">get_incoming_tracker_cookie</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a cookie which was set by the tracking server.</p>
<ul>
<li>
<p>@param name</p>
</li>
<li>
<p>@return bool|string</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_incoming_tracker_cookie(self, name):
    &#34;&#34;&#34;
    Gets a cookie which was set by the tracking server.

    * @param name

    * @return bool|string
    &#34;&#34;&#34;
    return self.incomingTrackerCookies.get(name, False)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_ip"><code class="name flex">
<span>def <span class="ident">get_ip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the currently set IP address.
* @return str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip(self):
    &#34;&#34;&#34;
    Returns the currently set IP address.
    * @return str
    &#34;&#34;&#34;
    return self.ip</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_proxy"><code class="name flex">
<span>def <span class="ident">get_proxy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the proxy IP,the proxy port and the proxy_type have been set,
with the set_proxy() function returns a string, like "https://173.234.92.107:80"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proxy(self):
    &#34;&#34;&#34;
    If the proxy IP,the proxy port and the proxy_type have been set,
    with the set_proxy() function returns a string, like &#34;https://173.234.92.107:80&#34;
    &#34;&#34;&#34;
    if self.proxy and self.proxy_port and self.proxy_type:
        return f&#34;{self.proxy_type}://{self.proxy}:{self.proxy_port}&#34;
    return None</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_request"><code class="name flex">
<span>def <span class="ident">get_request</span></span>(<span>self, id_site)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request(self, id_site):
    self.set_first_party_cookies()

    custom_fields = &#34;&#34;
    if self.customParameters:
        custom_fields = &#34;&amp;&#34; + urlencode_plus(self.customParameters)

    custom_dimensions = &#34;&#34;
    if self.customDimensions:
        custom_dimensions = &#34;&amp;&#34; + urlencode_plus(self.customDimensions)

    base_url = self.get_base_url()
    start = &#34;?&#34;
    if strpos(base_url, &#34;?&#34;):
        start = &#34;&amp;&#34;

    url = (
        f&#34;{base_url}{start}idsite={id_site}&amp;rec=1&amp;apiv={self.VERSION}&#34;
        + f&#34;&amp;r={str(random.randint(0, 2147483647))[2:8]}&#34;
        + (f&#34;&amp;cip={self.ip}&#34; if self.ip and self.token_auth else &#34;&#34;)
        + (f&#34;&amp;uid={urlencode_plus(self.user_id)}&#34; if self.user_id else &#34;&#34;)
        + (&#34;&amp;cdt=&#34; + urlencode_plus(self.forcedDatetime) if self.forcedDatetime else &#34;&#34;)
        + (&#34;&amp;new_visit=1&#34; if self.forcedNewVisit else &#34;&#34;)
        + f&#34;&amp;_idts={self.createTs}{self.plugins}&#34;
        + (
            f&#34;&amp;h={self.local_hour}&amp;m={self.local_minute}&amp;s={self.local_second}&#34;
            if self.local_hour and self.local_minute and self.local_second
            else &#34;&#34;
        )
        + (
            f&#34;&amp;res={self.width}x{self.height}&#34;
            if self.width and self.height
            else &#34;&#34;
        )
        + (f&#34;&amp;cookie={self.hasCookies}&#34; if self.hasCookies else &#34;&#34;)
        + (f&#34;&amp;data={self.customData}&#34; if self.customData else &#34;&#34;)
        + (
            &#34;&amp;_cvar=&#34; + urlencode_plus(json.dumps(self.visitorCustomVar))
            if self.visitorCustomVar
            else &#34;&#34;
        )
        + (
            &#34;&amp;cvar=&#34; + urlencode_plus(json.dumps(self.pageCustomVar))
            if self.pageCustomVar
            else &#34;&#34;
        )
        + (
            &#34;&amp;e_cvar=&#34; + urlencode_plus(json.dumps(self.eventCustomVar))
            if self.eventCustomVar
            else &#34;&#34;
        )
        + (
            f&#34;&amp;cid={self.forcedVisitorId}&#34;
            if self.forcedVisitorId
            else f&#34;&amp;_id={self.get_visitor_id()}&#34;
        )
        + &#34;&amp;url=&#34; + urlencode_plus(self.pageUrl)
        + &#34;&amp;urlref=&#34; + urlencode_plus(self.urlReferrer)
        + (
            f&#34;&amp;cs={self.pageCharset}&#34;
            if (
                self.pageCharset
                and self.pageCharset != self.DEFAULT_CHARSET_PARAMETER_VALUES
            )
            else &#34;&#34;
        )
        + (f&#34;&amp;pv_id={urlencode_plus(self.idPageview)}&#34; if self.idPageview else &#34;&#34;)
        + (
            &#34;&amp;_rcn=&#34; + urlencode_plus(self.attributionInfo[0])
            if self.attributionInfo and self.attributionInfo[0]
            else &#34;&#34;
        )
        + (
            &#34;&amp;_rck=&#34; + urlencode_plus(self.attributionInfo[1])
            if self.attributionInfo and self.attributionInfo[1]
            else &#34;&#34;
        )
        + (&#34;&amp;_refts=&#34; + self.attributionInfo[2] if self.attributionInfo and self.attributionInfo[2] else &#34;&#34;)
        + (
            &#34;&amp;_ref=&#34; + urlencode_plus(self.attributionInfo[3])
            if self.attributionInfo and self.attributionInfo[3]
            else &#34;&#34;
        )
        + (f&#34;&amp;country={urlencode_plus(self.country)}&#34; if self.country else &#34;&#34;)
        + (f&#34;&amp;region={urlencode_plus(self.region)}&#34; if self.region else &#34;&#34;)
        + (f&#34;&amp;city={urlencode_plus(self.city)}&#34;  if self.city else &#34;&#34;)
        + (f&#34;&amp;lat={urlencode_plus(str(self.lat))}&#34; if self.lat else &#34;&#34;)
        + (f&#34;&amp;long={urlencode_plus(str(self.long))}&#34; if self.long else &#34;&#34;)
        + custom_fields
        + custom_dimensions
        + (&#34;&amp;send_image=0&#34; if not self.sendImageResponse else &#34;&#34;)
        + self.DEBUG_APPEND_URL
    )

    if self.idPageview:
        url += (
            (f&#34;&amp;pf_net={self.networkTime}&#34; if self.networkTime else &#34;&#34;)
            + (f&#34;&amp;pf_srv={self.serverTime}&#34; if self.serverTime else &#34;&#34;)
            + (f&#34;&amp;pf_tfr={self.transferTime}&#34; if self.transferTime else &#34;&#34;)
            + (f&#34;&amp;pf_dm1={self.domProcessingTime}&#34; if self.domProcessingTime else &#34;&#34;)
            + (f&#34;&amp;pf_dm2={self.domCompletionTime}&#34; if self.domCompletionTime else &#34;&#34;)
            + (f&#34;&amp;pf_onl={self.onLoadTime}&#34; if self.onLoadTime else &#34;&#34;)
        )
        self.clear_performance_timings()

    for key in self.ecommerceView:
        url += f&#34;&amp;{key}={urlencode_plus(self.ecommerceView[key])}&#34;

    # Reset page level custom variables after this page view
    self.ecommerceView = {}
    self.pageCustomVar = {}
    self.eventCustomVar = {}
    self.clear_custom_dimensions()
    self.clear_custom_tracking_parameters()

    # force new visit only once, user must call again set_force_new_visit()
    self.forcedNewVisit = False

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_request_timeout"><code class="name flex">
<span>def <span class="ident">get_request_timeout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum number of seconds the tracker will spend waiting for a response
from Matomo. Defaults to 600 seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request_timeout(self):
    &#34;&#34;&#34;
    Returns the maximum number of seconds the tracker will spend waiting for a response
    from Matomo. Defaults to 600 seconds.
    &#34;&#34;&#34;
    return self.requestTimeout</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_timestamp"><code class="name flex">
<span>def <span class="ident">get_timestamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns current timestamp, or forced timestamp/datetime if it was set
* @return str|int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timestamp(self):
    &#34;&#34;&#34;
    Returns current timestamp, or forced timestamp/datetime if it was set
    * @return str|int
    &#34;&#34;&#34;
    if self.forcedDatetime:
        return datetime.strptime(self.forcedDatetime, &#34;%Y-%m-%d %H:%M:%S&#34;).timestamp()
    else:
        return time.time()</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_action"><code class="name flex">
<span>def <span class="ident">get_url_track_action</span></span>(<span>self, action_url, action_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a new action.</p>
<ul>
<li>@see do_track_action()</li>
<li>@param str action_url URL of the download or outlink</li>
<li>@param str action_type Type of the action: 'download' or 'link'</li>
<li>@return str URL to matomo.php with all parameters set to track an action</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_action(self, action_url, action_type):
    &#34;&#34;&#34;
    Builds URL to track a new action.

    * @see do_track_action()
    * @param str action_url URL of the download or outlink
    * @param str action_type Type of the action: &#39;download&#39; or &#39;link&#39;
    * @return str URL to matomo.php with all parameters set to track an action
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)
    url += f&#34;&amp;{action_type}={urlencode_plus(action_url)}&#34;
    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_content_impression"><code class="name flex">
<span>def <span class="ident">get_url_track_content_impression</span></span>(<span>self, content_name, content_piece, content_target)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a content impression.</p>
<ul>
<li>@see do_track_content_impression()</li>
<li>@param str content_name The name of the content. For instance 'Ad Foo Bar'</li>
<li>@param str content_piece The actual content. For instance the path to an image, video, audio, any text</li>
<li>@param str|False content_target (optional) The target of the content. For instance the URL of a landing page.</li>
<li>@throws Exception In case content_name is empty</li>
<li>@return str URL to matomo.php with all parameters set to track the pageview</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_content_impression(
    self, content_name, content_piece, content_target
):
    &#34;&#34;&#34;
    Builds URL to track a content impression.

    * @see do_track_content_impression()
    * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
    * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
    * @param str|False content_target (optional) The target of the content. For instance the URL of a landing page.
    * @throws Exception In case content_name is empty
    * @return str URL to matomo.php with all parameters set to track the pageview
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)

    if not content_name:
        raise Exception(&#34;You must specify a content name&#34;)

    url += f&#34;&amp;c_n={urlencode_plus(content_name)}&#34;

    if content_piece:
        url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
    if content_target:
        url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_content_interaction"><code class="name flex">
<span>def <span class="ident">get_url_track_content_interaction</span></span>(<span>self, interaction, content_name, content_piece, content_target)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a content impression.</p>
<ul>
<li>@see do_track_content_interaction()</li>
<li>@param str interaction The name of the interaction with the content. For instance a 'click'</li>
<li>@param str content_name The name of the content. For instance 'Ad Foo Bar'</li>
<li>@param str content_piece The actual content. For instance the path to an image, video, audio, any text</li>
<li>@param str|False content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.</li>
<li>@throws Exception In case interaction or content_name is empty</li>
<li>@return str URL to matomo.php with all parameters set to track the pageview</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_content_interaction(
    self, interaction, content_name, content_piece, content_target
):
    &#34;&#34;&#34;
    Builds URL to track a content impression.

    * @see do_track_content_interaction()
    * @param str interaction The name of the interaction with the content. For instance a &#39;click&#39;
    * @param str content_name The name of the content. For instance &#39;Ad Foo Bar&#39;
    * @param str content_piece The actual content. For instance the path to an image, video, audio, any text
    * @param str|False content_target (optional) The target the content leading to when an interaction occurs. For instance the URL of a landing page.
    * @throws Exception In case interaction or content_name is empty
    * @return str URL to matomo.php with all parameters set to track the pageview
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)

    if not interaction:
        raise Exception(&#34;You must specify a name for the interaction&#34;)

    if not content_name:
        raise Exception(&#34;You must specify a content name&#34;)

    url += f&#34;&amp;c_i={urlencode_plus(interaction)}&amp;c_n={urlencode_plus(content_name)}&#34;

    if content_piece:
        url += f&#34;&amp;c_p={urlencode_plus(content_piece)}&#34;
    if content_target:
        url += f&#34;&amp;c_t={urlencode_plus(content_target)}&#34;

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce"><code class="name flex">
<span>def <span class="ident">get_url_track_ecommerce</span></span>(<span>self, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns URL used to track Ecommerce orders</p>
<p>Calling this function will reinitialize the property ecommerceItems to empty array
so items will have to be added again via add_ecommerce_item()</p>
<ul>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_ecommerce(
    self, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
):
    &#34;&#34;&#34;
    Returns URL used to track Ecommerce orders

    Calling this function will reinitialize the property ecommerceItems to empty array
    so items will have to be added again via add_ecommerce_item()

    * @ignore
    &#34;&#34;&#34;
    if not is_numeric(grand_total) and not is_int(grand_total):
        raise Exception(
            &#34;You must specify a grand_total for the Ecommerce order (or Cart update)&#34;
        )

    url = self.get_request(self.id_site)
    url += &#34;&amp;idgoal=0&#34;
    if grand_total:
        grand_total = self.force_dot_as_separator_for_decimal_point(grand_total)
        url += f&#34;&amp;revenue={grand_total}&#34;
    if sub_total:
        sub_total = self.force_dot_as_separator_for_decimal_point(sub_total)
        url += f&#34;&amp;ec_st={sub_total}&#34;
    if tax:
        tax = self.force_dot_as_separator_for_decimal_point(tax)
        url += f&#34;&amp;ec_tx={tax}&#34;
    if shipping:
        shipping = self.force_dot_as_separator_for_decimal_point(shipping)
        url += f&#34;&amp;ec_sh={shipping}&#34;
    if discount:
        discount = self.force_dot_as_separator_for_decimal_point(discount)
        url += f&#34;&amp;ec_dt={discount}&#34;
    if self.ecommerceItems:
        url += &#34;&amp;ec_items=&#34; + urlencode_plus(json.dumps(self.ecommerceItems))
    self.ecommerceItems = []

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_cart_update"><code class="name flex">
<span>def <span class="ident">get_url_track_ecommerce_cart_update</span></span>(<span>self, grand_total)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns URL used to track Ecommerce Cart updates
Calling this function will reinitialize the property ecommerceItems to empty list
so items will have to be added again via add_ecommerce_item()
* @ignore</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_ecommerce_cart_update(self, grand_total):
    &#34;&#34;&#34;
    Returns URL used to track Ecommerce Cart updates
    Calling this function will reinitialize the property ecommerceItems to empty list
    so items will have to be added again via add_ecommerce_item()
    * @ignore
    &#34;&#34;&#34;
    url = self.get_url_track_ecommerce(grand_total)
    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_order"><code class="name flex">
<span>def <span class="ident">get_url_track_ecommerce_order</span></span>(<span>self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns URL used to track Ecommerce Orders
Calling this function will reinitialize the property ecommerceItems to empty list
so items will have to be added again via add_ecommerce_item()
* @ignore</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_ecommerce_order(
    self, order_id, grand_total, sub_total=0.0, tax=0.0, shipping=0.0, discount=0.0
):
    &#34;&#34;&#34;
    Returns URL used to track Ecommerce Orders
    Calling this function will reinitialize the property ecommerceItems to empty list
    so items will have to be added again via add_ecommerce_item()
    * @ignore
    &#34;&#34;&#34;
    if not order_id:
        raise Exception(&#34;You must specify an order_id for the Ecommerce order&#34;)
    url = self.get_url_track_ecommerce(
        grand_total, sub_total, tax, shipping, discount
    )
    url += &#34;&amp;ec_id=&#34; + urlencode_plus(order_id)

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_event"><code class="name flex">
<span>def <span class="ident">get_url_track_event</span></span>(<span>self, category, action, name='', value=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a custom event.</p>
<ul>
<li>@see do_track_event()</li>
<li>@param str category The Event Category (Videos, Music, Games&hellip;)</li>
<li>@param str action The Event's Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked&hellip;)</li>
<li>@param str name (optional) The Event's object Name (a particular Movie name, or Song name, or File name&hellip;)</li>
<li>@param float value (optional) The Event's value</li>
<li>@return str URL to matomo.php with all parameters set to track the pageview</li>
<li>@throws</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_event(self, category, action, name=&#34;&#34;, value=0):
    &#34;&#34;&#34;
    Builds URL to track a custom event.

    * @see do_track_event()
    * @param str category The Event Category (Videos, Music, Games...)
    * @param str action The Event&#39;s Action (Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
    * @param str name (optional) The Event&#39;s object Name (a particular Movie name, or Song name, or File name...)
    * @param float value (optional) The Event&#39;s value
    * @return str URL to matomo.php with all parameters set to track the pageview
    * @throws
    &#34;&#34;&#34;
    if not category:
        raise Exception(
            &#34;You must specify an Event Category name (Music, Videos, Games...).&#34;
        )
    if not action:
        raise Exception(&#34;You must specify an Event action (click, view, add...).&#34;)

    url = self.get_request(self.id_site)
    url += f&#34;&amp;e_c={urlencode_plus(category)}&amp;e_a={urlencode_plus(action)}&#34;

    if name:
        url += f&#34;&amp;e_n={urlencode_plus(name)}&#34;
    if value:
        value = self.force_dot_as_separator_for_decimal_point(value)
        url += f&#34;&amp;e_v={value}&#34;

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_goal"><code class="name flex">
<span>def <span class="ident">get_url_track_goal</span></span>(<span>self, id_goal, revenue=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a goal with id_goal and revenue.</p>
<ul>
<li>@see do_track_goal()</li>
<li>@param int id_goal Id Goal to record a conversion</li>
<li>@param float revenue Revenue for this conversion</li>
<li>@return str URL to matomo.php with all parameters set to track the goal conversion</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_goal(self, id_goal, revenue=0.0):
    &#34;&#34;&#34;
    Builds URL to track a goal with id_goal and revenue.

    * @see do_track_goal()
    * @param int id_goal Id Goal to record a conversion
    * @param float revenue Revenue for this conversion
    * @return str URL to matomo.php with all parameters set to track the goal conversion
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)
    url += f&#34;&amp;idgoal={id_goal}&#34;
    if revenue:
        revenue = self.force_dot_as_separator_for_decimal_point(revenue)
        url += f&#34;&amp;revenue={revenue}&#34;

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_page_view"><code class="name flex">
<span>def <span class="ident">get_url_track_page_view</span></span>(<span>self, document_title='')</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a page view.</p>
<ul>
<li>@see do_track_page_view()</li>
<li>@param str document_title Page view name as it will appear in Matomo reports</li>
<li>@return str URL to matomo.php with all parameters set to track the pageview</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_page_view(self, document_title=&#34;&#34;):
    &#34;&#34;&#34;
    Builds URL to track a page view.

    * @see do_track_page_view()
    * @param str document_title Page view name as it will appear in Matomo reports
    * @return str URL to matomo.php with all parameters set to track the pageview
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)
    if document_title:
        url += &#34;&amp;action_name=&#34; + urlencode_plus(document_title)
    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_url_track_site_search"><code class="name flex">
<span>def <span class="ident">get_url_track_site_search</span></span>(<span>self, keyword, category, count_results)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds URL to track a site search.</p>
<ul>
<li>@see do_track_site_search()</li>
<li>@param str keyword</li>
<li>@param str category</li>
<li>@param int count_results</li>
<li>@return str</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_track_site_search(self, keyword, category, count_results):
    &#34;&#34;&#34;
    Builds URL to track a site search.

    * @see do_track_site_search()
    * @param str keyword
    * @param str category
    * @param int count_results
    * @return str
    &#34;&#34;&#34;
    url = self.get_request(self.id_site)
    url += f&#34;&amp;search=&#34; + urlencode_plus(keyword)
    if category:
        url += f&#34;&amp;search_cat={urlencode_plus(category)}&#34;
    if count_results or count_results == 0:
        url += f&#34;&amp;search_count={count_results}&#34;

    return url</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_user_agent"><code class="name flex">
<span>def <span class="ident">get_user_agent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the currently set user agent.
* @return str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_agent(self):
    &#34;&#34;&#34;
    Returns the currently set user agent.
    * @return str
    &#34;&#34;&#34;
    return self.user_agent</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_user_id"><code class="name flex">
<span>def <span class="ident">get_user_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the User ID string, which may have been set via:
v.set_user_id('username@example.org')</p>
<ul>
<li>@return bool</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_id(self):
    &#34;&#34;&#34;
    Returns the User ID string, which may have been set via:
        v.set_user_id(&#39;username@example.org&#39;)

    * @return bool
    &#34;&#34;&#34;
    return self.user_id</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_user_id_hashed"><code class="name flex">
<span>def <span class="ident">get_user_id_hashed</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Hash function used internally by Matomo to hash a User ID into the Visitor ID.</p>
<p>Note: matches implementation of Tracker Request.get_user_id_hashed()</p>
<ul>
<li>@param id</li>
<li>@return str</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_id_hashed(self, id):
    &#34;&#34;&#34;
    Hash function used internally by Matomo to hash a User ID into the Visitor ID.

    Note: matches implementation of Tracker Request.get_user_id_hashed()

    * @param id
    * @return str
    &#34;&#34;&#34;
    return hashlib.sha1(id).hexdigest()[:16]</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.get_visitor_id"><code class="name flex">
<span>def <span class="ident">get_visitor_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the user initiating the request has the Matomo first party cookie, this function will try and
return the ID parsed from this first party cookie (self, found in self.request.cookie):.</p>
<p>If you call this function from a server, where the call is triggered by a cron or script
not initiated by the actual visitor being tracked, then it will return
the random Visitor ID that was assigned to this visit object.</p>
<p>This can be used if you wish to record more visits, actions or goals for this visitor ID later on.</p>
<ul>
<li>@return str 16 hex chars visitor ID string</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visitor_id(self):
    &#34;&#34;&#34;
    If the user initiating the request has the Matomo first party cookie, this function will try and
    return the ID parsed from this first party cookie (self, found in self.request.cookie):.

    If you call this function from a server, where the call is triggered by a cron or script
    not initiated by the actual visitor being tracked, then it will return
    the random Visitor ID that was assigned to this visit object.

    This can be used if you wish to record more visits, actions or goals for this visitor ID later on.

    * @return str 16 hex chars visitor ID string
    &#34;&#34;&#34;
    if self.forcedVisitorId:
        return self.forcedVisitorId
    if self.load_visitor_id_cookie():
        return self.cookieVisitorId
    return self.randomVisitorId</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.load_visitor_id_cookie"><code class="name flex">
<span>def <span class="ident">load_visitor_id_cookie</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads values from the VisitorId Cookie</p>
<ul>
<li>@return bool True if cookie exists and is valid, False otherwise</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_visitor_id_cookie(self):
    &#34;&#34;&#34;
    Loads values from the VisitorId Cookie

    * @return bool True if cookie exists and is valid, False otherwise
    &#34;&#34;&#34;
    id_cookie = self.get_cookie_matching_name(&#34;id&#34;)
    if not id_cookie:
        return False
    parts = id_cookie.split(&#34;.&#34;)
    if len(parts[0]) != self.LENGTH_VISITOR_ID:
        return False

    &#34;&#34;&#34; self.cookieVisitorId provides backward compatibility since get_visitor_id()
    didn&#39;t change any existing VisitorId value&#34;&#34;&#34;
    self.cookieVisitorId = parts[0]
    self.createTs = parts[1]
    return True</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.parse_incoming_cookies"><code class="name flex">
<span>def <span class="ident">parse_incoming_cookies</span></span>(<span>self, headers)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads incoming tracking server cookies.</p>
<ul>
<li>@param array headers Array with HTTP response headers as values</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_incoming_cookies(self, headers):
    &#34;&#34;&#34;
    Reads incoming tracking server cookies.

    * @param array headers Array with HTTP response headers as values
    &#34;&#34;&#34;
    self.incomingTrackerCookies = {}

    if headers:
        header_name = &#34;set-cookie:&#34;
        header_name_length = len(header_name)

        for header in headers:
            if strpos(header.lower(), header_name) != 0:
                continue
            cookies = header[header_name_length:].strip()
            pos_end = strpos(cookies, &#34;;&#34;)
            if pos_end is not False:  # 0 != False
                cookies = cookies[:pos_end]
            self.incomingTrackerCookies = parse_qs(cookies)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>self, url, method='get', data=None, force=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(self, url, method=&#34;get&#34;, data=None, force=False):
    raise NotImplementedError(&#34;Missing send_request implementation&#34;)</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_attribution_info"><code class="name flex">
<span>def <span class="ident">set_attribution_info</span></span>(<span>self, json_encoded)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the attribution information to the visit, so that subsequent Goal conversions are
properly attributed to the right Referrer URL, timestamp, Campaign Name &amp; Keyword.</p>
<p>This must be a JSON encoded string that would typically be fetched from the JS API:
matomoTracker.get_attribution_info() and that you have JSON encoded via JSON2.stringify()</p>
<p>If you call enable_cookies() then these referral attribution values will be set
to the 'ref' first party cookie storing referral information.</p>
<ul>
<li>@param str json_encoded JSON encoded list containing Attribution info</li>
<li>@return self</li>
<li>@throws Exception</li>
<li>@see def getAttributionInfo(self): in <a href="https://github.com/matomo-org/matomo/blob/master/js/matomo.js">https://github.com/matomo-org/matomo/blob/master/js/matomo.js</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attribution_info(self, json_encoded):
    &#34;&#34;&#34;
    Sets the attribution information to the visit, so that subsequent Goal conversions are
    properly attributed to the right Referrer URL, timestamp, Campaign Name &amp; Keyword.

    This must be a JSON encoded string that would typically be fetched from the JS API:
    matomoTracker.get_attribution_info() and that you have JSON encoded via JSON2.stringify()

    If you call enable_cookies() then these referral attribution values will be set
    to the &#39;ref&#39; first party cookie storing referral information.

    * @param str json_encoded JSON encoded list containing Attribution info
    * @return self
    * @throws Exception
    * @see def getAttributionInfo(self): in https://github.com/matomo-org/matomo/blob/master/js/matomo.js
    &#34;&#34;&#34;
    decoded = json.loads(json_encoded)
    if not is_list(decoded):
        raise Exception(
            f&#34;set_attribution_info() is expecting a JSON encoded string, &#39;{json_encoded}&#39; given&#34;
        )
    self.attributionInfo = decoded
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_browser_has_cookies"><code class="name flex">
<span>def <span class="ident">set_browser_has_cookies</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets if the browser supports cookies
This is reported in "List of plugins" report in Matomo.</p>
<ul>
<li>@param bool b</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_browser_has_cookies(self, b):
    &#34;&#34;&#34;
    Sets if the browser supports cookies
    This is reported in &#34;List of plugins&#34; report in Matomo.

    * @param bool b
    * @return self
    &#34;&#34;&#34;
    self.hasCookies = b
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_browser_language"><code class="name flex">
<span>def <span class="ident">set_browser_language</span></span>(<span>self, accept_language)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the Browser language. Used to guess visitor countries when GeoIP is not enabled</p>
<ul>
<li>@param str accept_language For example "fr-fr"</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_browser_language(self, accept_language):
    &#34;&#34;&#34;
    Sets the Browser language. Used to guess visitor countries when GeoIP is not enabled

    * @param str accept_language For example &#34;fr-fr&#34;
    * @return self
    &#34;&#34;&#34;
    self.accept_language = accept_language
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_city"><code class="name flex">
<span>def <span class="ident">set_city</span></span>(<span>self, city)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the city of the visitor. If not used, Matomo may try to find the city
using the visitor's IP address (if configured to do so).</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth().
* @param str city
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_city(self, city):
    &#34;&#34;&#34;
    Sets the city of the visitor. If not used, Matomo may try to find the city
    using the visitor&#39;s IP address (if configured to do so).

    Allowed only for Admin/Super User, must be used along with set_token_auth().
    * @param str city
    * @return self
    &#34;&#34;&#34;
    self.city = city
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_cookie"><code class="name flex">
<span>def <span class="ident">set_cookie</span></span>(<span>self, cookie_name, cookie_value, cookie_ttl)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a first party cookie to the client to improve dual JS-Python tracking.</p>
<p>This replicates the matomo.js tracker algorithms for consistency and better accuracy.</p>
<ul>
<li>@param cookie_name</li>
<li>@param cookie_value</li>
<li>@param cookie_ttl</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cookie(self, cookie_name, cookie_value, cookie_ttl):
    &#34;&#34;&#34;
    Sets a first party cookie to the client to improve dual JS-Python tracking.

    This replicates the matomo.js tracker algorithms for consistency and better accuracy.

    * @param cookie_name
    * @param cookie_value
    * @param cookie_ttl
    * @return self
    &#34;&#34;&#34;
    cookie_expire = self.currentTs + cookie_ttl
    self.request.cookie.set(cookie_name, cookie_value, expires=cookie_expire)
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_country"><code class="name flex">
<span>def <span class="ident">set_country</span></span>(<span>self, country)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the country of the visitor. If not used, Matomo will try to find the country
using either the visitor's IP address or language.</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth().
* @param str country
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_country(self, country):
    &#34;&#34;&#34;
    Sets the country of the visitor. If not used, Matomo will try to find the country
    using either the visitor&#39;s IP address or language.

    Allowed only for Admin/Super User, must be used along with set_token_auth().
    * @param str country
    * @return self
    &#34;&#34;&#34;
    self.country = country
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_custom_dimension"><code class="name flex">
<span>def <span class="ident">set_custom_dimension</span></span>(<span>self, id, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a specific custom dimension</p>
<ul>
<li>@param int id id of custom dimension</li>
<li>@param str value value for custom dimension</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_dimension(self, id, value):
    &#34;&#34;&#34;
    Sets a specific custom dimension

    * @param int id id of custom dimension
    * @param str value value for custom dimension
    * @return self
    &#34;&#34;&#34;
    self.customDimensions[f&#34;dimension{id}&#34;] = value
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_custom_tracking_parameter"><code class="name flex">
<span>def <span class="ident">set_custom_tracking_parameter</span></span>(<span>self, tracking_api_parameter, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a custom tracking parameter. This is useful if you need to send any tracking parameters for a 3rd party
plugin that is not shipped with Matomo itself. Please note that custom parameters are cleared after each
tracking request.</p>
<ul>
<li>@param str tracking_api_parameter The name of the tracking API parameter, eg 'bw_bytes'</li>
<li>@param str value Tracking parameter value that shall be sent for this tracking parameter.</li>
<li>@return self</li>
<li>@throws Exception</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_tracking_parameter(self, tracking_api_parameter, value):
    &#34;&#34;&#34;
    Sets a custom tracking parameter. This is useful if you need to send any tracking parameters for a 3rd party
    plugin that is not shipped with Matomo itself. Please note that custom parameters are cleared after each
    tracking request.

    * @param str tracking_api_parameter The name of the tracking API parameter, eg &#39;bw_bytes&#39;
    * @param str value Tracking parameter value that shall be sent for this tracking parameter.
    * @return self
    * @throws Exception
    &#34;&#34;&#34;
    regex = re.compile(&#39;/^dimension([0-9]+)$/&#39;)
    matches = re.findall(regex, tracking_api_parameter)
    if len(matches):
        # Unlike PHP preg_match it returns captured subpattern as first element
        self.set_custom_dimension(matches[0], value)
        return self

    self.customParameters[tracking_api_parameter] = value
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_custom_variable"><code class="name flex">
<span>def <span class="ident">set_custom_variable</span></span>(<span>self, id, name, value, scope='visit')</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Visit Custom Variable.
See <a href="https://matomo.org/docs/custom-variables/">https://matomo.org/docs/custom-variables/</a></p>
<ul>
<li>@param int id Custom variable slot ID from 1-5</li>
<li>@param str name Custom variable name</li>
<li>@param str value Custom variable value</li>
<li>@param str scope Custom variable scope. Possible values: visit, page, event</li>
<li>@return self</li>
<li>@throws Exception</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_custom_variable(self, id, name, value, scope=&#34;visit&#34;):
    &#34;&#34;&#34;
    Sets Visit Custom Variable.
    See https://matomo.org/docs/custom-variables/

    * @param int id Custom variable slot ID from 1-5
    * @param str name Custom variable name
    * @param str value Custom variable value
    * @param str scope Custom variable scope. Possible values: visit, page, event
    * @return self
    * @throws Exception
    &#34;&#34;&#34;
    if not is_int(id):
        raise Exception(&#34;Parameter id to set_custom_variable should be an integer&#34;)
    if scope == &#34;page&#34;:
        self.pageCustomVar[id] = [name, value]
    elif scope == &#34;event&#34;:
        self.eventCustomVar[id] = [name, value]
    elif scope == &#34;visit&#34;:
        self.visitorCustomVar[id] = [name, value]
    else:
        raise Exception(&#34;Invalid &#39;scope&#39; parameter value&#34;)
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_debug_string_append"><code class="name flex">
<span>def <span class="ident">set_debug_string_append</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>Will append a custom string at the end of the Tracking request.
* @param str string
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug_string_append(self, string):
    &#34;&#34;&#34;
    Will append a custom string at the end of the Tracking request.
    * @param str string
    * @return self
    &#34;&#34;&#34;
    self.DEBUG_APPEND_URL = &#34;&amp;&#34; + string
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_ecommerce_view"><code class="name flex">
<span>def <span class="ident">set_ecommerce_view</span></span>(<span>self, sku='', name='', category='', price=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current page view as an item (product) page view, or an Ecommerce Category page view.</p>
<p>This must be called before do_track_page_view() on this product/category page.</p>
<p>On a category page, you may set the parameter category only and set the other parameters to False.</p>
<p>Tracking Product/Category page views will allow Matomo to report on Product &amp; Categories
conversion rates (Conversion rate = Ecommerce orders containing this product or category / Visits to the product or category)</p>
<ul>
<li>@param str sku Product SKU being viewed</li>
<li>@param str name Product Name being viewed</li>
<li>@param str|array category Category being viewed. On a Product page, this is the product's category.
You can also specify an array of up to 5 categories for a given page view.</li>
<li>@param float price Specify the price at which the item was displayed</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ecommerce_view(self, sku=&#34;&#34;, name=&#34;&#34;, category=&#34;&#34;, price=0.0):
    &#34;&#34;&#34;
    Sets the current page view as an item (product) page view, or an Ecommerce Category page view.

    This must be called before do_track_page_view() on this product/category page.

    On a category page, you may set the parameter category only and set the other parameters to False.

    Tracking Product/Category page views will allow Matomo to report on Product &amp; Categories
    conversion rates (Conversion rate = Ecommerce orders containing this product or category / Visits to the product or category)

    * @param str sku Product SKU being viewed
    * @param str name Product Name being viewed
    * @param str|array category Category being viewed. On a Product page, this is the product&#39;s category.
                                   You can also specify an array of up to 5 categories for a given page view.
    * @param float price Specify the price at which the item was displayed
    * @return self
    &#34;&#34;&#34;
    self.ecommerceView = {}
    if category:
        if is_list(category):
            category = json.dumps(category)

    self.ecommerceView[&#34;_pkc&#34;] = category

    if price:
        price = str(price)
        price = self.force_dot_as_separator_for_decimal_point(price)
        self.ecommerceView[&#34;_pkp&#34;] = price

    # On a category page, do not record &#34;Product name not defined&#34;
    if not sku and not name:
        return self
    if sku:
        self.ecommerceView[&#34;_pks&#34;] = sku
    if not name:
        name = &#34;&#34;
    self.ecommerceView[&#34;_pkn&#34;] = name
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_first_party_cookies"><code class="name flex">
<span>def <span class="ident">set_first_party_cookies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the first party cookies as would the matomo.js
All cookies are supported: 'id' and 'ses' and 'ref' and 'cvar' cookies.
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_first_party_cookies(self):
    &#34;&#34;&#34;
    Sets the first party cookies as would the matomo.js
    All cookies are supported: &#39;id&#39; and &#39;ses&#39; and &#39;ref&#39; and &#39;cvar&#39; cookies.
    * @return self
    &#34;&#34;&#34;
    if self.configCookiesDisabled:
        return self

    if self.cookieVisitorId:
        self.load_visitor_id_cookie()

    # Set the &#39;ref&#39; cookie
    attribution_info = self.get_attribution_info()
    if attribution_info:
        self.set_cookie(&#34;ref&#34;, attribution_info, self.configReferralCookieTimeout)

    # Set the &#39;ses&#39; cookie
    self.set_cookie(&#34;ses&#34;, &#34;*&#34;, self.configSessionCookieTimeout)

    # Set the &#39;id&#39; cookie
    cookie_value = f&#34;{self.get_visitor_id()}.{self.createTs}&#34;
    self.set_cookie(&#34;id&#34;, cookie_value, self.configVisitorCookieTimeout)

    # Set the &#39;cvar&#39; cookie
    self.set_cookie(
        &#34;cvar&#34;, json.dumps(self.visitorCustomVar), self.configSessionCookieTimeout
    )
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_force_new_visit"><code class="name flex">
<span>def <span class="ident">set_force_new_visit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces Matomo to create a new visit for the tracking request.</p>
<p>By default, Matomo will create a new visit if the last request by this user was more than 30 minutes ago.
If you call set_force_new_visit() before calling do_track*, then a new visit will be created for this request.
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_force_new_visit(self):
    &#34;&#34;&#34;
    Forces Matomo to create a new visit for the tracking request.

    By default, Matomo will create a new visit if the last request by this user was more than 30 minutes ago.
    If you call set_force_new_visit() before calling do_track*, then a new visit will be created for this request.
    * @return self
    &#34;&#34;&#34;
    self.forcedNewVisit = True
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_force_visit_date_time"><code class="name flex">
<span>def <span class="ident">set_force_visit_date_time</span></span>(<span>self, date_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides server date and time for the tracking requests.
By default Matomo will track requests for the "current datetime" but this function allows you
to track visits in the past. All times are in UTC.</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth()
* @see set_token_auth()
* @param str date_time Date with the format '%y-%m-%d %H:%M:%S', or a UNIX timestamp.
If the datetime is older than one day (default value for
tracking_requests_require_authentication_when_custom_timestamp_newer_than),
then you must call set_token_auth() with a valid Admin/Super user token.
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_force_visit_date_time(self, date_time):
    &#34;&#34;&#34;
    Overrides server date and time for the tracking requests.
    By default Matomo will track requests for the &#34;current datetime&#34; but this function allows you
    to track visits in the past. All times are in UTC.

    Allowed only for Admin/Super User, must be used along with set_token_auth()
    * @see set_token_auth()
    * @param str date_time Date with the format &#39;%y-%m-%d %H:%M:%S&#39;, or a UNIX timestamp.
                  If the datetime is older than one day (default value for
                  tracking_requests_require_authentication_when_custom_timestamp_newer_than),
                  then you must call set_token_auth() with a valid Admin/Super user token.
    * @return self
    &#34;&#34;&#34;
    self.forcedDatetime = date_time
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_generation_time"><code class="name flex">
<span>def <span class="ident">set_generation_time</span></span>(<span>self, time_ms)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is deprecated and does nothing. It used to set the time that it took to generate the document on the server side.</p>
<ul>
<li>@param int time_ms Generation time in ms</li>
<li>
<p>@return self</p>
</li>
<li>
<p>@deprecated this metric is deprecated please use performance timings instead</p>
</li>
<li>@see setPerformanceTimings</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_generation_time(self, time_ms):
    &#34;&#34;&#34;
    This method is deprecated and does nothing. It used to set the time that it took to generate the document on the server side.

    * @param int time_ms Generation time in ms
    * @return self

    * @deprecated this metric is deprecated please use performance timings instead
    * @see setPerformanceTimings
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_id_site"><code class="name flex">
<span>def <span class="ident">set_id_site</span></span>(<span>self, id_site)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current site ID.</p>
<ul>
<li>@param int id_site</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_id_site(self, id_site):
    &#34;&#34;&#34;
    Sets the current site ID.

    * @param int id_site
    * @return self
    &#34;&#34;&#34;
    self.id_site = id_site
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_ip"><code class="name flex">
<span>def <span class="ident">set_ip</span></span>(<span>self, ip)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides IP address</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth()
* @see set_token_auth()
* @param str ip IP string, eg. 130.54.2.1
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ip(self, ip):
    &#34;&#34;&#34;
    Overrides IP address

    Allowed only for Admin/Super User, must be used along with set_token_auth()
    * @see set_token_auth()
    * @param str ip IP string, eg. 130.54.2.1
    * @return self
    &#34;&#34;&#34;
    self.ip = ip
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_latitude"><code class="name flex">
<span>def <span class="ident">set_latitude</span></span>(<span>self, lat)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the latitude of the visitor. If not used, Matomo may try to find the visitor's
latitude using the visitor's IP address (if configured to do so).</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth().
* @param float lat
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_latitude(self, lat):
    &#34;&#34;&#34;
    Sets the latitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
    latitude using the visitor&#39;s IP address (if configured to do so).

    Allowed only for Admin/Super User, must be used along with set_token_auth().
    * @param float lat
    * @return self
    &#34;&#34;&#34;
    self.lat = lat
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_local_time"><code class="name flex">
<span>def <span class="ident">set_local_time</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets local visitor time</p>
<ul>
<li>@param str t HH:MM:SS format</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local_time(self, t):
    &#34;&#34;&#34;
    Sets local visitor time

    * @param str t HH:MM:SS format
    * @return self
    &#34;&#34;&#34;
    hour, minute, second = t.split(&#34;:&#34;)
    self.local_hour = hour
    self.local_minute = minute
    self.local_second = second
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_longitude"><code class="name flex">
<span>def <span class="ident">set_longitude</span></span>(<span>self, long)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the longitude of the visitor. If not used, Matomo may try to find the visitor's
longitude using the visitor's IP address (if configured to do so).</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth().
* @param float long
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_longitude(self, long):
    &#34;&#34;&#34;
    Sets the longitude of the visitor. If not used, Matomo may try to find the visitor&#39;s
    longitude using the visitor&#39;s IP address (if configured to do so).

    Allowed only for Admin/Super User, must be used along with set_token_auth().
    * @param float long
    * @return self
    &#34;&#34;&#34;
    self.long = long
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_new_visitor_id"><code class="name flex">
<span>def <span class="ident">set_new_visitor_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current visitor ID to a random new one.
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_new_visitor_id(self):
    &#34;&#34;&#34;
    Sets the current visitor ID to a random new one.
    * @return self
    &#34;&#34;&#34;
    self.randomVisitorId = uuid.uuid4().hex[: self.LENGTH_VISITOR_ID]
    self.forcedVisitorId = False
    self.cookieVisitorId = False
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_outgoing_tracker_cookie"><code class="name flex">
<span>def <span class="ident">set_outgoing_tracker_cookie</span></span>(<span>self, name, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a cookie to be sent to the tracking server.</p>
<ul>
<li>@param name</li>
<li>@param value</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outgoing_tracker_cookie(self, name, value=None):
    &#34;&#34;&#34;
    Sets a cookie to be sent to the tracking server.

    * @param name
    * @param value
    &#34;&#34;&#34;
    if value is None:
        del self.outgoingTrackerCookies[name]
    else:
        self.outgoingTrackerCookies[name] = value</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_page_charset"><code class="name flex">
<span>def <span class="ident">set_page_charset</span></span>(<span>self, charset='')</span>
</code></dt>
<dd>
<div class="desc"><p>By default, Matomo expects utf-8 encoded values, for example
for the page URL parameter values, Page Title, etc.
It is recommended to only send UTF-8 data to Matomo.
If required though, you can also specify another charset using this function.</p>
<ul>
<li>@param str charset</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_page_charset(self, charset=&#34;&#34;):
    &#34;&#34;&#34;
    By default, Matomo expects utf-8 encoded values, for example
    for the page URL parameter values, Page Title, etc.
    It is recommended to only send UTF-8 data to Matomo.
    If required though, you can also specify another charset using this function.

    * @param str charset
    * @return self
    &#34;&#34;&#34;
    self.pageCharset = charset
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_performance_timings"><code class="name flex">
<span>def <span class="ident">set_performance_timings</span></span>(<span>self, network=0, server=0, transfer=0, domProcessing=0, domCompletion=0, onLoad=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets timings for various browser performance metrics.
* @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming">https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming</a></p>
<ul>
<li>@param int network Network time in ms (connectEnd – fetchStart)</li>
<li>@param int server Server time in ms (responseStart – requestStart)</li>
<li>@param int transfer Transfer time in ms (responseEnd – responseStart)</li>
<li>@param int domProcessing DOM Processing to Interactive time in ms (domInteractive – domLoading)</li>
<li>@param int domCompletion DOM Interactive to Complete time in ms (domComplete – domInteractive)</li>
<li>@param int onload Onload time in ms (loadEventEnd – loadEventStart)</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_performance_timings(self, network=0, server=0, transfer=0, domProcessing=0, domCompletion=0, onLoad=0):
    &#34;&#34;&#34;
    Sets timings for various browser performance metrics.
    * @see https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming

    * @param int network Network time in ms (connectEnd – fetchStart)
    * @param int server Server time in ms (responseStart – requestStart)
    * @param int transfer Transfer time in ms (responseEnd – responseStart)
    * @param int domProcessing DOM Processing to Interactive time in ms (domInteractive – domLoading)
    * @param int domCompletion DOM Interactive to Complete time in ms (domComplete – domInteractive)
    * @param int onload Onload time in ms (loadEventEnd – loadEventStart)
    * @return self
    &#34;&#34;&#34;
    self.networkTime = network
    self.serverTime = server
    self.transferTime = transfer
    self.domProcessingTime = domProcessing
    self.domCompletionTime = domCompletion
    self.onLoadTime = onLoad
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_plugins"><code class="name flex">
<span>def <span class="ident">set_plugins</span></span>(<span>self, flash=False, java=False, quick_time=False, real_player=False, pdf=False, windows_media=False, silverlight=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets visitor browser supported plugins</p>
<ul>
<li>@param bool flash</li>
<li>@param bool java</li>
<li>@param bool quick_time</li>
<li>@param bool real_player</li>
<li>@param bool pdf</li>
<li>@param bool windows_media</li>
<li>@param bool silverlight</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_plugins(
    self,
    flash=False,
    java=False,
    quick_time=False,
    real_player=False,
    pdf=False,
    windows_media=False,
    silverlight=False,
):
    &#34;&#34;&#34;
    Sets visitor browser supported plugins

    * @param bool flash
    * @param bool java
    * @param bool quick_time
    * @param bool real_player
    * @param bool pdf
    * @param bool windows_media
    * @param bool silverlight
    * @return self
    &#34;&#34;&#34;
    plugins = (
        f&#34;&amp;fla={int(flash)}&amp;java={int(java)}&amp;qt={int(quick_time)}&#34;
        f&#34;&amp;realp={int(real_player)}&amp;pdf={int(pdf)}&amp;wma={int(windows_media)}&amp;ag={int(silverlight)}&#34;
    )
    self.plugins = plugins
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_proxy"><code class="name flex">
<span>def <span class="ident">set_proxy</span></span>(<span>self, proxy, proxy_port=80, proxy_type='https')</span>
</code></dt>
<dd>
<div class="desc"><p>If a proxy is needed to look up the address of the Matomo site, set it with this
* @param str proxy IP as string, for example "173.234.92.107"
* @param int proxy_port</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_proxy(self, proxy, proxy_port=80, proxy_type=&#34;https&#34;):
    &#34;&#34;&#34;
    If a proxy is needed to look up the address of the Matomo site, set it with this
    * @param str proxy IP as string, for example &#34;173.234.92.107&#34;
    * @param int proxy_port
    &#34;&#34;&#34;
    self.proxy = proxy
    self.proxy_port = proxy_port
    self.proxy_type = proxy_type</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_region"><code class="name flex">
<span>def <span class="ident">set_region</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the region of the visitor. If not used, Matomo may try to find the region
using the visitor's IP address (if configured to do so).</p>
<p>Allowed only for Admin/Super User, must be used along with set_token_auth().
* @param str region
* @return self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_region(self, region):
    &#34;&#34;&#34;
    Sets the region of the visitor. If not used, Matomo may try to find the region
    using the visitor&#39;s IP address (if configured to do so).

    Allowed only for Admin/Super User, must be used along with set_token_auth().
    * @param str region
    * @return self
    &#34;&#34;&#34;
    self.region = region
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_request_method_non_bulk"><code class="name flex">
<span>def <span class="ident">set_request_method_non_bulk</span></span>(<span>self, method)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the request method to POST, which is recommended when using set_token_auth()
to prevent the token from being recorded in server logs. Avoid using redirects
when using POST to prevent the loss of POST values. When using Log Analytics,
be aware that POST requests are not parseable/replayable.</p>
<ul>
<li>@param str method. Either 'POST' or 'get'</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_request_method_non_bulk(self, method):
    &#34;&#34;&#34;
    Sets the request method to POST, which is recommended when using set_token_auth()
    to prevent the token from being recorded in server logs. Avoid using redirects
    when using POST to prevent the loss of POST values. When using Log Analytics,
    be aware that POST requests are not parseable/replayable.

    * @param str method. Either &#39;POST&#39; or &#39;get&#39;
    * @return self
    &#34;&#34;&#34;
    self.request_method = &#34;POST&#34; if method.upper() == &#34;POST&#34; else &#34;GET&#34;
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_request_timeout"><code class="name flex">
<span>def <span class="ident">set_request_timeout</span></span>(<span>self, timeout)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the maximum number of seconds that the tracker will spend waiting for a response
from Matomo.</p>
<ul>
<li>@param int timeout</li>
<li>@return self</li>
<li>@throws Exception</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_request_timeout(self, timeout):
    &#34;&#34;&#34;
    Sets the maximum number of seconds that the tracker will spend waiting for a response
    from Matomo.

    * @param int timeout
    * @return self
    * @throws Exception
    &#34;&#34;&#34;
    if not is_int(timeout) or timeout &lt; 0:
        raise Exception(&#34;Invalid value supplied for request timeout: timeout&#34;)

    self.requestTimeout = timeout
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_resolution"><code class="name flex">
<span>def <span class="ident">set_resolution</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets user resolution width and height.</p>
<ul>
<li>@param int width</li>
<li>@param int height</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_resolution(self, width, height):
    &#34;&#34;&#34;
    Sets user resolution width and height.

    * @param int width
    * @param int height
    * @return self
    &#34;&#34;&#34;
    self.width = width
    self.height = height
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_token_auth"><code class="name flex">
<span>def <span class="ident">set_token_auth</span></span>(<span>self, token_auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Some Tracking API functionality requires express authentication, using either the
Super User token_auth, or a user with 'admin' access to the website.</p>
<p>The following features require access:
- force the visitor IP
- force the date &amp; time of the tracking requests rather than track for the current datetime</p>
<ul>
<li>@param str token_auth token_auth 32 chars token_auth string</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_token_auth(self, token_auth):
    &#34;&#34;&#34;
    Some Tracking API functionality requires express authentication, using either the
    Super User token_auth, or a user with &#39;admin&#39; access to the website.

    The following features require access:
    - force the visitor IP
    - force the date &amp; time of the tracking requests rather than track for the current datetime

    * @param str token_auth token_auth 32 chars token_auth string
    * @return self
    &#34;&#34;&#34;
    self.token_auth = token_auth
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_url"><code class="name flex">
<span>def <span class="ident">set_url</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the current URL being tracked</p>
<ul>
<li>@param str url Raw URL (not URL encoded)</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_url(self, url):
    &#34;&#34;&#34;
    Sets the current URL being tracked

    * @param str url Raw URL (not URL encoded)
    * @return self
    &#34;&#34;&#34;
    self.pageUrl = url
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_url_referer"><code class="name flex">
<span>def <span class="ident">set_url_referer</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>@deprecated</li>
<li>@ignore</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_url_referer(self, url):
    &#34;&#34;&#34;
    * @deprecated
    * @ignore
    &#34;&#34;&#34;
    self.set_url_referrer(url)
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_url_referrer"><code class="name flex">
<span>def <span class="ident">set_url_referrer</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the URL referrer used to track Referrers details for new visits.</p>
<ul>
<li>@param str url Raw URL (not URL encoded)</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_url_referrer(self, url):
    &#34;&#34;&#34;
    Sets the URL referrer used to track Referrers details for new visits.

    * @param str url Raw URL (not URL encoded)
    * @return self
    &#34;&#34;&#34;
    self.urlReferrer = url
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_user_agent"><code class="name flex">
<span>def <span class="ident">set_user_agent</span></span>(<span>self, user_agent)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the user agent, used to detect OS and browser.
If this function is not called, the User Agent will default to the current user agent.</p>
<ul>
<li>@param str user_agent</li>
<li>@return self</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_user_agent(self, user_agent):
    &#34;&#34;&#34;
    Sets the user agent, used to detect OS and browser.
    If this function is not called, the User Agent will default to the current user agent.

    * @param str user_agent
    * @return self
    &#34;&#34;&#34;
    self.user_agent = user_agent
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_user_id"><code class="name flex">
<span>def <span class="ident">set_user_id</span></span>(<span>self, user_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Force the action to be recorded for a specific User. The User ID is a string representing a given user in your system.</p>
<p>A User ID can be a username, UUID or an email address, or any number or string that uniquely identifies a user or client.</p>
<ul>
<li>@param str user_id Any user ID string (eg. email address, ID, username). Must be non empty. Set to False to de-assign a user id previously set.</li>
<li>@return self</li>
<li>@throws Exception</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_user_id(self, user_id):
    &#34;&#34;&#34;
    Force the action to be recorded for a specific User. The User ID is a string representing a given user in your system.

    A User ID can be a username, UUID or an email address, or any number or string that uniquely identifies a user or client.

    * @param str user_id Any user ID string (eg. email address, ID, username). Must be non empty. Set to False to de-assign a user id previously set.
    * @return self
    * @throws Exception
    &#34;&#34;&#34;
    if user_id == &#34;&#34;:
        raise Exception(&#34;User ID cannot be empty.&#34;)
    self.user_id = user_id
    return self</code></pre>
</details>
</dd>
<dt id="src.matomo.tracker.MatomoTracker.set_visitor_id"><code class="name flex">
<span>def <span class="ident">set_visitor_id</span></span>(<span>self, visitor_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces the requests to be recorded for the specified Visitor ID.</p>
<p>Rather than letting Matomo attribute the user with a heuristic based on IP and other user
fingerprinting attributes, force the action to be recorded for a particular visitor.</p>
<p>If not set, the visitor ID will be fetched from the 1st party cookie, or will be set to a random UUID.</p>
<ul>
<li>@param str visitor_id 16 hexadecimal characters visitor ID, eg. "33c31e01394bdc63"</li>
<li>@return self</li>
<li>@throws Exception</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_visitor_id(self, visitor_id):
    &#34;&#34;&#34;
    Forces the requests to be recorded for the specified Visitor ID.

    Rather than letting Matomo attribute the user with a heuristic based on IP and other user
    fingerprinting attributes, force the action to be recorded for a particular visitor.

    If not set, the visitor ID will be fetched from the 1st party cookie, or will be set to a random UUID.

    * @param str visitor_id 16 hexadecimal characters visitor ID, eg. &#34;33c31e01394bdc63&#34;
    * @return self
    * @throws Exception
    &#34;&#34;&#34;
    hex_chars = &#34;01234567890abcdefABCDEF&#34;
    if len(visitor_id) != self.LENGTH_VISITOR_ID or strspn(
        visitor_id, hex_chars
    ) != len(visitor_id):
        raise Exception(
            f&#34;set_visitor_id() expects a {self.LENGTH_VISITOR_ID} characters&#34;
            f&#34; hexadecimal string (containing only the following: {hex_chars})&#34;
        )
    self.forcedVisitorId = visitor_id
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.matomo" href="index.html">src.matomo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="src.matomo.tracker.is_dict" href="#src.matomo.tracker.is_dict">is_dict</a></code></li>
<li><code><a title="src.matomo.tracker.is_int" href="#src.matomo.tracker.is_int">is_int</a></code></li>
<li><code><a title="src.matomo.tracker.is_list" href="#src.matomo.tracker.is_list">is_list</a></code></li>
<li><code><a title="src.matomo.tracker.is_numeric" href="#src.matomo.tracker.is_numeric">is_numeric</a></code></li>
<li><code><a title="src.matomo.tracker.strpos" href="#src.matomo.tracker.strpos">strpos</a></code></li>
<li><code><a title="src.matomo.tracker.strspn" href="#src.matomo.tracker.strspn">strspn</a></code></li>
<li><code><a title="src.matomo.tracker.urlencode_plus" href="#src.matomo.tracker.urlencode_plus">urlencode_plus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.matomo.tracker.MatomoTracker" href="#src.matomo.tracker.MatomoTracker">MatomoTracker</a></code></h4>
<ul class="">
<li><code><a title="src.matomo.tracker.MatomoTracker.DEBUG_APPEND_URL" href="#src.matomo.tracker.MatomoTracker.DEBUG_APPEND_URL">DEBUG_APPEND_URL</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.DEFAULT_CHARSET_PARAMETER_VALUES" href="#src.matomo.tracker.MatomoTracker.DEFAULT_CHARSET_PARAMETER_VALUES">DEFAULT_CHARSET_PARAMETER_VALUES</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.DEFAULT_COOKIE_PATH" href="#src.matomo.tracker.MatomoTracker.DEFAULT_COOKIE_PATH">DEFAULT_COOKIE_PATH</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.FIRST_PARTY_COOKIES_PREFIX" href="#src.matomo.tracker.MatomoTracker.FIRST_PARTY_COOKIES_PREFIX">FIRST_PARTY_COOKIES_PREFIX</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.LENGTH_VISITOR_ID" href="#src.matomo.tracker.MatomoTracker.LENGTH_VISITOR_ID">LENGTH_VISITOR_ID</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.MAX_NUM_ECOMMERCE_ITEM_CATEGORIES" href="#src.matomo.tracker.MatomoTracker.MAX_NUM_ECOMMERCE_ITEM_CATEGORIES">MAX_NUM_ECOMMERCE_ITEM_CATEGORIES</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.URL" href="#src.matomo.tracker.MatomoTracker.URL">URL</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.VERSION" href="#src.matomo.tracker.MatomoTracker.VERSION">VERSION</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.add_ecommerce_item" href="#src.matomo.tracker.MatomoTracker.add_ecommerce_item">add_ecommerce_item</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.clear_custom_dimensions" href="#src.matomo.tracker.MatomoTracker.clear_custom_dimensions">clear_custom_dimensions</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.clear_custom_tracking_parameters" href="#src.matomo.tracker.MatomoTracker.clear_custom_tracking_parameters">clear_custom_tracking_parameters</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.clear_custom_variables" href="#src.matomo.tracker.MatomoTracker.clear_custom_variables">clear_custom_variables</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.clear_performance_timings" href="#src.matomo.tracker.MatomoTracker.clear_performance_timings">clear_performance_timings</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.delete_cookies" href="#src.matomo.tracker.MatomoTracker.delete_cookies">delete_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.disable_cookie_support" href="#src.matomo.tracker.MatomoTracker.disable_cookie_support">disable_cookie_support</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.disable_send_image_response" href="#src.matomo.tracker.MatomoTracker.disable_send_image_response">disable_send_image_response</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_bulk_track" href="#src.matomo.tracker.MatomoTracker.do_bulk_track">do_bulk_track</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_ping" href="#src.matomo.tracker.MatomoTracker.do_ping">do_ping</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_action" href="#src.matomo.tracker.MatomoTracker.do_track_action">do_track_action</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_content_impression" href="#src.matomo.tracker.MatomoTracker.do_track_content_impression">do_track_content_impression</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_content_interaction" href="#src.matomo.tracker.MatomoTracker.do_track_content_interaction">do_track_content_interaction</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_ecommerce_cart_update" href="#src.matomo.tracker.MatomoTracker.do_track_ecommerce_cart_update">do_track_ecommerce_cart_update</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_ecommerce_order" href="#src.matomo.tracker.MatomoTracker.do_track_ecommerce_order">do_track_ecommerce_order</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_event" href="#src.matomo.tracker.MatomoTracker.do_track_event">do_track_event</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_goal" href="#src.matomo.tracker.MatomoTracker.do_track_goal">do_track_goal</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_page_view" href="#src.matomo.tracker.MatomoTracker.do_track_page_view">do_track_page_view</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.do_track_site_search" href="#src.matomo.tracker.MatomoTracker.do_track_site_search">do_track_site_search</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.domain_fixup" href="#src.matomo.tracker.MatomoTracker.domain_fixup">domain_fixup</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.enable_bulk_tracking" href="#src.matomo.tracker.MatomoTracker.enable_bulk_tracking">enable_bulk_tracking</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.enable_cookies" href="#src.matomo.tracker.MatomoTracker.enable_cookies">enable_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.force_dot_as_separator_for_decimal_point" href="#src.matomo.tracker.MatomoTracker.force_dot_as_separator_for_decimal_point">force_dot_as_separator_for_decimal_point</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.generate_new_pageview_id" href="#src.matomo.tracker.MatomoTracker.generate_new_pageview_id">generate_new_pageview_id</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_attribution_info" href="#src.matomo.tracker.MatomoTracker.get_attribution_info">get_attribution_info</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_base_url" href="#src.matomo.tracker.MatomoTracker.get_base_url">get_base_url</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_cookie_matching_name" href="#src.matomo.tracker.MatomoTracker.get_cookie_matching_name">get_cookie_matching_name</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_cookie_name" href="#src.matomo.tracker.MatomoTracker.get_cookie_name">get_cookie_name</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_cookies" href="#src.matomo.tracker.MatomoTracker.get_cookies">get_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_current_host" href="#src.matomo.tracker.MatomoTracker.get_current_host">get_current_host</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_current_query_string" href="#src.matomo.tracker.MatomoTracker.get_current_query_string">get_current_query_string</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_current_scheme" href="#src.matomo.tracker.MatomoTracker.get_current_scheme">get_current_scheme</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_current_script_name" href="#src.matomo.tracker.MatomoTracker.get_current_script_name">get_current_script_name</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_current_url" href="#src.matomo.tracker.MatomoTracker.get_current_url">get_current_url</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_custom_dimension" href="#src.matomo.tracker.MatomoTracker.get_custom_dimension">get_custom_dimension</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_custom_variable" href="#src.matomo.tracker.MatomoTracker.get_custom_variable">get_custom_variable</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_custom_variables_from_cookie" href="#src.matomo.tracker.MatomoTracker.get_custom_variables_from_cookie">get_custom_variables_from_cookie</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_incoming_tracker_cookie" href="#src.matomo.tracker.MatomoTracker.get_incoming_tracker_cookie">get_incoming_tracker_cookie</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_ip" href="#src.matomo.tracker.MatomoTracker.get_ip">get_ip</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_proxy" href="#src.matomo.tracker.MatomoTracker.get_proxy">get_proxy</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_request" href="#src.matomo.tracker.MatomoTracker.get_request">get_request</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_request_timeout" href="#src.matomo.tracker.MatomoTracker.get_request_timeout">get_request_timeout</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_timestamp" href="#src.matomo.tracker.MatomoTracker.get_timestamp">get_timestamp</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_action" href="#src.matomo.tracker.MatomoTracker.get_url_track_action">get_url_track_action</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_content_impression" href="#src.matomo.tracker.MatomoTracker.get_url_track_content_impression">get_url_track_content_impression</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_content_interaction" href="#src.matomo.tracker.MatomoTracker.get_url_track_content_interaction">get_url_track_content_interaction</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce" href="#src.matomo.tracker.MatomoTracker.get_url_track_ecommerce">get_url_track_ecommerce</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_cart_update" href="#src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_cart_update">get_url_track_ecommerce_cart_update</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_order" href="#src.matomo.tracker.MatomoTracker.get_url_track_ecommerce_order">get_url_track_ecommerce_order</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_event" href="#src.matomo.tracker.MatomoTracker.get_url_track_event">get_url_track_event</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_goal" href="#src.matomo.tracker.MatomoTracker.get_url_track_goal">get_url_track_goal</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_page_view" href="#src.matomo.tracker.MatomoTracker.get_url_track_page_view">get_url_track_page_view</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_url_track_site_search" href="#src.matomo.tracker.MatomoTracker.get_url_track_site_search">get_url_track_site_search</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_user_agent" href="#src.matomo.tracker.MatomoTracker.get_user_agent">get_user_agent</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_user_id" href="#src.matomo.tracker.MatomoTracker.get_user_id">get_user_id</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_user_id_hashed" href="#src.matomo.tracker.MatomoTracker.get_user_id_hashed">get_user_id_hashed</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.get_visitor_id" href="#src.matomo.tracker.MatomoTracker.get_visitor_id">get_visitor_id</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.load_visitor_id_cookie" href="#src.matomo.tracker.MatomoTracker.load_visitor_id_cookie">load_visitor_id_cookie</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.parse_incoming_cookies" href="#src.matomo.tracker.MatomoTracker.parse_incoming_cookies">parse_incoming_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.send_request" href="#src.matomo.tracker.MatomoTracker.send_request">send_request</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_attribution_info" href="#src.matomo.tracker.MatomoTracker.set_attribution_info">set_attribution_info</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_browser_has_cookies" href="#src.matomo.tracker.MatomoTracker.set_browser_has_cookies">set_browser_has_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_browser_language" href="#src.matomo.tracker.MatomoTracker.set_browser_language">set_browser_language</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_city" href="#src.matomo.tracker.MatomoTracker.set_city">set_city</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_cookie" href="#src.matomo.tracker.MatomoTracker.set_cookie">set_cookie</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_country" href="#src.matomo.tracker.MatomoTracker.set_country">set_country</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_custom_dimension" href="#src.matomo.tracker.MatomoTracker.set_custom_dimension">set_custom_dimension</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_custom_tracking_parameter" href="#src.matomo.tracker.MatomoTracker.set_custom_tracking_parameter">set_custom_tracking_parameter</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_custom_variable" href="#src.matomo.tracker.MatomoTracker.set_custom_variable">set_custom_variable</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_debug_string_append" href="#src.matomo.tracker.MatomoTracker.set_debug_string_append">set_debug_string_append</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_ecommerce_view" href="#src.matomo.tracker.MatomoTracker.set_ecommerce_view">set_ecommerce_view</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_first_party_cookies" href="#src.matomo.tracker.MatomoTracker.set_first_party_cookies">set_first_party_cookies</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_force_new_visit" href="#src.matomo.tracker.MatomoTracker.set_force_new_visit">set_force_new_visit</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_force_visit_date_time" href="#src.matomo.tracker.MatomoTracker.set_force_visit_date_time">set_force_visit_date_time</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_generation_time" href="#src.matomo.tracker.MatomoTracker.set_generation_time">set_generation_time</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_id_site" href="#src.matomo.tracker.MatomoTracker.set_id_site">set_id_site</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_ip" href="#src.matomo.tracker.MatomoTracker.set_ip">set_ip</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_latitude" href="#src.matomo.tracker.MatomoTracker.set_latitude">set_latitude</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_local_time" href="#src.matomo.tracker.MatomoTracker.set_local_time">set_local_time</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_longitude" href="#src.matomo.tracker.MatomoTracker.set_longitude">set_longitude</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_new_visitor_id" href="#src.matomo.tracker.MatomoTracker.set_new_visitor_id">set_new_visitor_id</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_outgoing_tracker_cookie" href="#src.matomo.tracker.MatomoTracker.set_outgoing_tracker_cookie">set_outgoing_tracker_cookie</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_page_charset" href="#src.matomo.tracker.MatomoTracker.set_page_charset">set_page_charset</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_performance_timings" href="#src.matomo.tracker.MatomoTracker.set_performance_timings">set_performance_timings</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_plugins" href="#src.matomo.tracker.MatomoTracker.set_plugins">set_plugins</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_proxy" href="#src.matomo.tracker.MatomoTracker.set_proxy">set_proxy</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_region" href="#src.matomo.tracker.MatomoTracker.set_region">set_region</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_request_method_non_bulk" href="#src.matomo.tracker.MatomoTracker.set_request_method_non_bulk">set_request_method_non_bulk</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_request_timeout" href="#src.matomo.tracker.MatomoTracker.set_request_timeout">set_request_timeout</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_resolution" href="#src.matomo.tracker.MatomoTracker.set_resolution">set_resolution</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_token_auth" href="#src.matomo.tracker.MatomoTracker.set_token_auth">set_token_auth</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_url" href="#src.matomo.tracker.MatomoTracker.set_url">set_url</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_url_referer" href="#src.matomo.tracker.MatomoTracker.set_url_referer">set_url_referer</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_url_referrer" href="#src.matomo.tracker.MatomoTracker.set_url_referrer">set_url_referrer</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_user_agent" href="#src.matomo.tracker.MatomoTracker.set_user_agent">set_user_agent</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_user_id" href="#src.matomo.tracker.MatomoTracker.set_user_id">set_user_id</a></code></li>
<li><code><a title="src.matomo.tracker.MatomoTracker.set_visitor_id" href="#src.matomo.tracker.MatomoTracker.set_visitor_id">set_visitor_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>